intArray,"int[] intArray = getNumbers();"
persons,"Person[] persons = getPersons();"
personList,"Person[] personList = getPersons();"
personArray,"int[] personArray = getPersons();"
intArray,"int[] intList = getNumbers();"
numbers,"int[] numbers = getNumbers();"
numbersArray,"int[] numbersArray = getNumbers();"
numbersList,"int[] numbersList = getNumbers();"
count,"int count = getCount();"
name,"string name = getName();"
age,"int age = getAge();"
isAuthorized,"boolean isAuthorized = checkAuthorization();"
isRaining,"boolean isRaining = false;"
isFlag,"boolean isFlag = true;"
salary,"float salary = getSalary();"
names,"string[] names = getNames();"
payload,"json payload = getPayload();"
dateList,"Date[] dateList = [];"
dateArray,"Date[] dateArray = [];"
totalPrice,"float totalPrice = calculateTotalPrice();"
message,"string message = getMessage();"
isFound,"boolean isFound = findItem();"
employees,"Employee[] employees = getEmployees();"
students,"Students[] students = getStudents();"
order,"Order order = getOrder();"
student,"Student student;"
person,"Person person = {name: 'John'};"
persons,"Person[] persons = getPersons();"
persons,"Person[] persons = getPersons(10, 'Sales');"
num,"int num;"
daysOfWeek,"DayOfWeek[] daysOfWeek = [SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY];"
utcOffset,"ZoneOffset utcOffset = <ZoneOffset>civilTime?.utcOffset;"
civilTimeSecField,"decimal? civilTimeSecField = civilTime?.second;"
utcOffsetSecField,"decimal? utcOffsetSecField = utcOffset?.seconds;"
civilTimeSeconds,"decimal civilTimeSeconds = (civilTimeSecField is Seconds) ? civilTimeSecField : 0.0;"
utcOffsetSeconds,"decimal utcOffsetSeconds = (utcOffsetSecField is decimal) ? utcOffsetSecField : 0.0;"
utcOffset,"ZoneOffset utcOffset = <ZoneOffset>civil?.utcOffset;"
civilTimeSecField,"decimal? civilTimeSecField = civil?.second;"
utcOffsetHours,"int utcOffsetHours = 0;"
utcOffsetMinutes,"int utcOffsetMinutes = 0;"
utcOffsetSeconds,"decimal utcOffsetSeconds = 0.0;"
utcOffset,"ZoneOffset? utcOffset = civil?.utcOffset;"
timeAbbrevField,"string? timeAbbrevField = civil?.timeAbbrev;"
timeAbbrev,"string timeAbbrev = (timeAbbrevField is string) ? timeAbbrevField : \"\";"
jsonKey,"string jsonKey = k.trim();"
node,"xml node = check traverseNode(value, allNamespaces, namespacesOfElem, options, jsonKey);"
node,"xml node = check getElement(jsonKey, check traverseNode(value, allNamespaces, namespacesOfElem, options), allNamespaces, options, check getAttributesMap(value, options, allNamespaces, parentNamespaces));"
arrayEntryTagKey,"string arrayEntryTagKey = \"\";"
item,"xml item;"
jMap,"map<anydata>|error jMap = node.ensureType();"
attributePrefix,"string attributePrefix = options.attributePrefix;"
element,"xml:Element element;"
index,"int? index = name.indexOf(\":\");"
prefix,"string prefix = name.substring(0, index);"
elementName,"string elementName = name.substring(index + 1, name.length());"
namespaceUrl,"string namespaceUrl = attributes[string `{${XMLNS_NAMESPACE_URI}}${prefix}`].toString();"
newAttributes,"map<string> newAttributes = attributes;"
value,"string value = newAttributes.get(string `{${XMLNS_NAMESPACE_URI}}`);"
attributes,"map<string> attributes = parentNamespaces.clone();"
attr,"map<json>|error attr = jTree.ensureType();"
index,"int? index = k.indexOf(\":\");"
suffix,"string suffix = k.substring(index + 1);"
startIndex,"int startIndex = getStartIndex(attributePrefix, k);"
prefix,"string prefix = k.substring(startIndex, index);"
namespaceUrl,"string namespaceUrl = namespaces.get(string `{${XMLNS_NAMESPACE_URI}}${prefix}`);"
startIndex,"int startIndex = 1;"
location,"int? location = key.indexOf(\"_\");"
namespaces,"map<string> namespaces = parentNamespaces.clone();"
prefix,"string prefix = k.substring(index + 1);"
cn,"string cn = check charAt(path, index);"
value,"string value = check charAt(path, index);"
c0,"string c0 = check charAt(path, 0);"
c1,"string c1 = check charAt(path, 1);"
size,"int size = path.length();"
c2,"string c2 = check charAt(path, 2);"
n,"int n = 3;"
cn,"string cn = check charAt(path, n);"
normalizedPath,"string normalizedPath = \"\";"
length,"int length = path.length();"
offset,"int offset = check nextNonSlashIndex(path, off, length);"
startIndex,"int startIndex = offset;"
c,"string c = check charAt(path, offset);"
validatedPath,"string validatedPath = check parse(path);"
offsetIndexes,"int[] offsetIndexes = check getOffsetIndexes(validatedPath);"
count,"int count = offsetIndexes.length();"
root,"string root;"
offset,"int offset;"
i,"int i = 0;"
parts,"string[] parts = [];"
ignore,"boolean[] ignore = [];"
parentRef,"boolean[] parentRef = [];"
remaining,"int remaining = count;"
begin,"int begin = offsetIndexes[i];"
length,"int length;"
j,"int j = i - 1;"
hasPrevious,"boolean hasPrevious = false;"
lowerCasePath,"string lowerCasePath = path.toLowerAscii();"
cleanBase,"string cleanBase = check normalizePath(base, CLEAN);"
cleanTarget,"string cleanTarget = check normalizePath(target, CLEAN);"
baseRoot,"string baseRoot;"
baseOffset,"int baseOffset;"
targetRoot,"string targetRoot;"
targetOffset,"int targetOffset;"
b0,"int b0 = baseOffset;"
bi,"int bi = baseOffset;"
t0,"int t0 = targetOffset;"
ti,"int ti = targetOffset;"
bl,"int bl = cleanBase.length();"
tl,"int tl = cleanTarget.length();"
remainder,"string remainder = cleanBase.substring(b0, bl);"
offsets,"int[] offsets = check getOffsetIndexes(remainder);"
noSeparators,"int noSeparators = offsets.length() - 1;"
relativePath,"string relativePath = \"..\";"
offset,"int offset = 0;"
root,"string root = \"\";"
n,"int n = input.length();"
prevC,"string prevC = \"\";"
c,"string c = check charAt(input, i);"
off,"int off = offset;"
regEx,"string regEx = \"^[a-zA-Z]{1}$\";"
letter,"boolean|error letter = regex:matches(c,regEx);"
length,"int length = input.length();"
a,"string[] a;"
b,"string b;"
pathCreated,"error? pathCreated = trap createLink();"
path,"string path = getTmpDir() + \"/test_link.txt\";"
resPath,"string|error resPath = normalizePath(path, SYMLINK);"
expected,"string|error expected = getSymLink();"
removeLinkResult,"error? removeLinkResult = trap removeLink();"
path,"string path = \"tests/resources/test.txt\";"
path,"string path = \"tests/resources/test_non_existent.txt\";"
path,"string path = \"/hoMe/UseR/\";"
normpath,"string|error normpath = normalizePath(path, NORMCASE);"
isAbs,"boolean|error isAbs = isAbsolutePath(path);"
fname,"string|error fname = basename(path);"
parentName,"string|error parentName = parentPath(input);"
normPath,"string|error normPath = normalizePath(input, CLEAN);"
path,"string[]|error path = splitPath(input);"
exvalues,"string[] exvalues = regex:split(expected, \",\");"
arrSize,"int arrSize = path.length();"
bpath,"string|error bpath = joinPath(...parts);"
relPath,"string|error relPath = relativePath(basePath, targetPath);"
headers,"map<string|string[]> headers = {};"
message,"AddItemRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.CartService/AddItem\", message, headers);"
message,"GetCartRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.CartService/GetCart\", message, headers);"
message,"EmptyCartRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.CartService/EmptyCart\", message, headers);"
message,"ListRecommendationsRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.RecommendationService/ListRecommendations\", message, headers);"
message,"Empty message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.ProductCatalogService/ListProducts\", message, headers);"
message,"GetProductRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.ProductCatalogService/GetProduct\", message, headers);"
message,"SearchProductsRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.ProductCatalogService/SearchProducts\", message, headers);"
message,"GetQuoteRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.ShippingService/GetQuote\", message, headers);"
message,"ShipOrderRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.ShippingService/ShipOrder\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.CurrencyService/GetSupportedCurrencies\", message, headers);"
message,"CurrencyConversionRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.CurrencyService/Convert\", message, headers);"
message,"ChargeRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.PaymentService/Charge\", message, headers);"
message,"SendOrderConfirmationRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.EmailService/SendOrderConfirmation\", message, headers);"
message,"PlaceOrderRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.CheckoutService/PlaceOrder\", message, headers);"
message,"AdRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"hipstershop.AdService/GetAds\", message, headers);"
textPrompt,"text:CreateCompletionRequest textPrompt = { prompt: string `generate a product descirption in 250 words about ${name}`, model: \"text-davinci-003\", max_tokens: 100 };"
completionRes,"text:CreateCompletionResponse completionRes = check openAIText->/completions.post(textPrompt);"
imagePrmt,"images:CreateImageRequest imagePrmt = {prompt: string `${name}, ${benefits}, ${features}`};"
imageRes,"images:ImagesResponse imageRes = check openAIImages->/images/generations.post(imagePrmt);"
product,"shopify:CreateProduct product = { product: { title: name, body_html: completionRes.choices[0].text, tags: features, product_type: productType, images: [{src: imageRes.data[0].url}] } };"
prodObj,"shopify:ProductObject prodObj = check shopify->createProduct(product);"
pid,"int? pid = prodObj?.product?.id;"
lastRowIndex,"int lastRowIndex = range.values.length() - 1;"
row,"(int|string|decimal)[] row = range.values[lastRowIndex];"
message,"string message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"Albums/getAlbum\", message, headers);"
message,"Album message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"Albums/addAlbum\", message, headers);"
message,"empty:Empty message = {};"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"Albums/listAlbums\", message, headers);"
outputStream,"AlbumStream outputStream = new AlbumStream(result);"
streamValue,"var streamValue = self.anydataStream.next();"
nextRecord,"record {|Album value;|} nextRecord = {value: <Album>streamValue.value};"
clientEndpoint,"final http:Client clientEndpoint = check new (\"https: timeout: 10, httpVersion: http:HTTP_1_1"
returnArray,"(int|error)[] returnArray = [];"
count,"int count = -1;"
data,"record {|record {} value;|}? data = check queryResult.next();"
variable,"record {} variable = data.value;"
dbClient1,"Client dbClient1 = check new (jdbcUrl, user, password, options);"
dbClient2,"Client dbClient2 = check new (jdbcUrl, user, password, options);"
dbClient3,"Client dbClient3 = check new (jdbcUrl, user, password, options);"
dbClient4,"Client dbClient4 = check new (jdbcUrl, user, password, options);"
dbClient5,"Client dbClient5 = check new (jdbcUrl, user, password, options);"
resultArray,"stream<record {}, error?>[] resultArray = [];"
value,"record {} value = data.value;"
sqlError,"sql:ApplicationError sqlError = <sql:ApplicationError>dbError;"
sqlError,"sql:DatabaseError sqlError = <sql:DatabaseError>dbError;"
rwType,"MappingAtomicType rwType = { names: names.cloneReadOnly(), types: types.cloneReadOnly(), rest };"
roType,"MappingAtomicType roType = { names: rwType.names, types: readOnlyTypeList(rwType.types), rest: intersect(rest, READONLY) };"
roBdd,"readonly & bdd:Node roBdd = bdd:atom(self.ro);"
rwBdd,"readonly & bdd:Node rwBdd;"
s,"SemType s = new SemType(0, [[UT_MAPPING_RO, roBdd], [UT_MAPPING_RW, rwBdd]]);"
i,"int i = env.mappingDefs.length();"
dummy,"MappingAtomicType dummy = { names: [], types: [], rest: NEVER };"
sortedFields,"Field[] sortedFields = fields.sort(\"ascending\", fieldName);"
names,"string[] names = [];"
types,"SemType[] types = [];"
b,"bdd:Bdd b = <bdd:Bdd>t;"
mm,"BddMemo? mm = tc.mappingMemo[b];"
m,"BddMemo m;"
res,"boolean? res = m.isEmpty;"
isEmpty,"boolean isEmpty = bddEvery(tc, b, (), (), mappingFormulaIsEmpty);"
combined,"TempMappingSubtype combined;"
p,"Conjunction? p = posList.next;"
m,"var m = intersectMapping(combined, tc.mappingDefs[p.atom]);"
neg,"MappingAtomicType neg = tc.mappingDefs[negList.atom];"
pairing,"MappingPairing pairing;"
d,"SemType d = diff(posType, negType);"
mt,"TempMappingSubtype mt;"
i,"int? i = pairing.index1(name);"
posTypes,"SemType[] posTypes = shallowCopyTypes(pos.types);"
names,"string[] names = shallowCopyStrings(m.names);"
types,"SemType[] types = shallowCopyTypes(m.types);"
i,"int i = names.length();"
t,"SemType t = intersect(type1, type2);"
rest,"SemType rest = intersect(m1.rest, m2.rest);"
i1Prev,"int i1Prev = self.i1 - 1;"
p,"FieldPair p;"
name1,"string name1 = self.curName1();"
name2,"string name2 = self.curName2();"
c,"int c = code;"
some,"int some = self.some;"
subtypeList,"UniformSubtype[] subtypeList = [];"
code,"var code = <UniformTypeCode>numberOfTrailingZeros(some);"
loBits,"int loBits = self.some & (c - 1);"
n,"int n = 0;"
v,"int v = bits;"
flag,"int flag = 1;"
all1,"UniformTypeBitSet all1;"
all2,"UniformTypeBitSet all2;"
some1,"UniformTypeBitSet some1;"
some2,"UniformTypeBitSet some2;"
all,"UniformTypeBitSet all = all1 | all2;"
some,"UniformTypeBitSet some = (some1 | some2) & ~<int>all;"
subtypes,"UniformSubtype[] subtypes = [];"
data,"SubtypeData data;"
union,"var union = ops[code].union;"
all,"UniformTypeBitSet all = all1 & all2;"
some,"UniformTypeBitSet some = (some1 | all1) & (some2 | all2);"
intersect,"var intersect = ops[code].intersect;"
all,"UniformTypeBitSet all = all1 & ~<int>(all2 | some2);"
some,"UniformTypeBitSet some = (all1 | some1) & ~<int>all2;"
complement,"var complement = ops[code].complement;"
diff,"var diff = ops[code].diff;"
isEmpty,"var isEmpty = ops[code].isEmpty;"
bits,"UniformTypeBitSet bits;"
listDef,"ListDefinition listDef = new;"
mapDef,"MappingDefinition mapDef = new;"
simple,"SemType simple = uniformTypeUnion((1 << UT_NIL) | (1 << UT_BOOLEAN) | (1 << UT_INT)| (1 << UT_FLOAT)| (1 << UT_DECIMAL)| (1 << UT_STRING));"
j,"SemType j = union(simple, union(listDef.getSemType(env), mapDef.getSemType(env)));"
db,"DefBinding db = { desc, def, next };"
fields,"core:Field[] fields = [];"
f,"core:Field f = check parseField(env, b, jlist[i], pathAppend(parent, i));"
name,"json name = j[0];"
t,"core:SemType t = check parseType(env, b, j[1], pathAppend(path, 1));"
tem,"Binding? tem = b;"
loop,"boolean loop = true;"
nb,"NameBinding nb = { name, next: b, desc: t, path };"
s,"core:SemType[] s = [];"
t,"core:SemType t = check parseType(env, b, js[i], pathAppend(parent, i));"
result,"core:SemType result = binary(v[0], v[1]);"
path,"Path path = parent.clone();"
lines,"string[] lines = from var [name1, name2] in results let string s = name1 + \"<:\" + name2 order by s select s;"
env,"core:Env env = new;"
firstOk,"boolean firstOk = false;"
ok,"boolean ok = true;"
t1,"core:SemType t1 = check j:parse(env, j1);"
t2,"core:SemType t2 = check j:parse(env, j2);"
expect,"var expect = <[boolean,boolean]>relationExpect[rel];"
tem,"int tem = bdd:getCount();"
tc,"var tc = core:typeCheckContext(env);"
b,"boolean b = core:isSubtype(tc, t1, t2);"
index,"int? index = self.uniqueGreetings.indexOf(greeting);"
nextVal,"record {|int value;|} nextVal = {value: self.integers[self.cursor]};"
doubled,"int[] doubled = intArray.map(function(int value) returns int { return value * 2; });"
sortedArray,"int[] sortedArray = intArray.sort(array:DESCENDING, isolated function(int value) returns string[] { if (value < 5) { return [\"Z\", value.toString()]; } else { return [\"B\", value.toString()]; } });"
f1,"future<int> f1 = start calculate(\"365*24\");"
f2,"future<int> f2 = @strand {thread: \"any\"} start multiply(1, 2);"
hoursInYear,"int hoursInYear = wait f1;"
result2,"record { int r1; int r2; } result2 = wait {r1: f1, r2: f1};"
a,"int a = -385;"
b,"int:Unsigned8 b = 128;"
res1,"int:Unsigned8 res1 = a & b;"
byteVal,"byte byteVal = 12;"
byteArray1,"byte[] byteArray1 = [5, 24, 56, 243];"
byteArray2,"byte[] byteArray2 = base16 `aeeecdefabcd12345567888822`;"
byteArray3,"byte[] byteArray3 = base64 `aGVsbG8gYmFsbGVyaW5hICEhIQ==`;"
countryCapitals,"map<string> countryCapitals = { \"USA\": \"Washington, D.C.\", \"Sri Lanka\": \"Colombo\", \"England\": \"London\" };"
books,"xml books = xml `<books> <book> <name>Sherlock Holmes</name> <author>Sir Arthur Conan Doyle</author> </book> <book> <name>Harry Potter</name> <author>J.K. Rowling</author> </book> </books>`;"
p1,"Person|error p1 = new(\"John\");"
value,"string|int|boolean value = 10;"
fields,"anydata[] fields = [];"
httpClient,"http:Client httpClient = checkpanic new (\"https:"
response,"string response = <string>checkpanic httpClient->get(string `/v4/?expr=${expr}`, targetType = string);"
result,"json result = { RequestID: ctx.getRequestId(), DeadlineMS: ctx.getDeadlineMs(), InvokedFunctionArn: ctx.getInvokedFunctionArn(), TraceID: ctx.getTraceId(), RemainingExecTime: ctx.getRemainingExecutionTime() };"
jsonRes2,"json jsonRes2 = { \"args\": {}, \"data\": \"POST: Hello World\", \"files\": {}, \"form\": {}, \"json\": null, \"url\": \"https: };"
j1,"json j1 = [1, false, null, \"foo\", {first: \"John\", last: \"Bob\"}];"
imagePath,"string imagePath = \"./files/ballerina.jpg\";"
isString,"boolean isString = imagePath is string;"
bytes,"byte[] bytes = check io:fileReadBytes(imagePath);"
blockStream,"stream<io:Block, io:Error> blockStream = check io:fileReadBlocksAsStream(imagePath, 2048);"
key,"string key = \"somesecret\";"
keyArr,"byte[] keyArr = key.toBytes();"
csvContent,"string[][] csvContent = [[\"1\", \"James\", \"10000\"], [\"2\", \"Nathan\", \"150000\"], [\"3\", \"Ronald\", \"120000\"], [\"4\", \"Roy\", \"6000\"], [\"5\", \"Oliver\", \"1100000\"]];"
csvStream,"stream<string[], io:Error> csvStream = check io:fileReadCsvAsStream(\"/path\");"
e,"error? e = csvStream.forEach(function(string[] val) { io:println(val); });"
readCsv,"string[][] readCsv = check io:fileReadCsv(\"csvFilePath1\");"
input,"string? input = ();"
name,"string name = input is () ? \"John Doe\" : input;"
t1,"[string|int, float, boolean] t1 = [1, 1.0, false];"
t2,"[int, float|string, boolean] t2 = [1, 1.0, false];"
v1,"[string, string] v1 = [\"Sample String\", \"Sample String 2\"];"
parsedNum,"int parsedNum = check parse(\"12\");"
parsedStr,"int parsedStr = check parse(\"invalid\");"
res,"var res = commit;"
invalidAccoundIdError,"error invalidAccoundIdError = error(\"INVALID_ACCOUNT_ID\", accountID = 7);"
canVote,"function (Person) returns boolean canVote = (p) => p.age >= 18;"
toEmployee,"var toEmployee = function(Person p, string pos) returns Employee => { name: p.name, designation: pos };"
t,"string t = \"Hello \".concat(name);"
immutableDetails,"Details & readonly immutableDetails = { name: \"May\", id: 112233 };"
codes,"final string[] & readonly codes = [\"AB\", \"CD\"];"
marks,"map<int> & readonly marks = { math: 80, physics: 85, chemistry: 75 };"
d,"readonly d = 5;"
m5,"map<string|int> m5 = {valueType: \"map\", constraint: \"string\"};"
a,"int a = let int b = 1 in b * 2;"
greeting,"string greeting = let string hello = \"Hello \", string ballerina = \"Ballerina!\" in hello + ballerina;"
length,"int length = let var num = 10, var txt = \"four\" in num + txt.length();"
three,"int three = let int one = 1, int two = one + one in one + two;"
v2,"[int, int] v2 = [10, 20];"
tupleBindingResult,"int tupleBindingResult = let [int, int] [d1, d2] = v2, int d3 = d1 + d2 in d3 * 2;"
value,"any|error value = val.reduce(getStringValue, \"\");"
aValue,"string aValue = a is error ? a.toString() : a.toString();"
bValue,"string bValue = b is error ? b.toString() : b.toString();"
cache,"cache:Cache cache = new ({ capacity: 10, evictionFactor: 0.2, defaultMaxAgeInSeconds: 2, cleanupIntervalInSeconds: 3 });"
value,"string value = <string>check cache.get(\"key1\");"
keys,"string[] keys = cache.keys();"
w,"int|error w = parse(\"12\");"
y,"int y = checkpanic parse(\"120\");"
response1,"json response1 = { name: \"San Francisco Test Station,USA\", longitude: -122.43, latitude: 37.76, altitude: 150, rank: 1 };"
httpEndpoint,"http:Client httpEndpoint = checkpanic new (\"http: http:Request req = new;"
response,"var response = httpEndpoint->post(\"/cbr/route\", req);"
jsonRes,"var jsonRes = check response.getJsonPayload();"
nameString,"json|error nameString = response1;"
response2,"http:Response|http:PayloadType|error response2;"
result,"var result = httpEndpoint->respond(<@untainted>response2);"
insertRecords,"var insertRecords = [ {firstName: \"Peter\", lastName: \"Stuart\", registrationID: 1, creditLimit: 5000.75, country: \"USA\"}, {firstName: \"Stephanie\", lastName: \"Mike\", registrationID: 2, creditLimit: 8000.00, country: \"USA\"}, {firstName: \"Bill\", lastName: \"John\", registrationID: 3, creditLimit: 3000.25, country: \"USA\"} ];"
insertQueries,"sql:ParameterizedQuery[] insertQueries = from var data in insertRecords select `INSERT INTO Customers (firstName, lastName, registrationID, creditLimit, country) VALUES (${data.firstName}, ${data.lastName}, ${data.registrationID}, ${data.creditLimit}, ${data.country})`;"
b1,"[string, int]|[boolean, int]|[int, boolean]|int|float b1 = [\"Hello\", 45];"
a,"int a = 3;"
foo,"var foo = function(int b) returns int { int c = 34; if (b == 3) { c = c + b + a + moduleA; } return c + a; };"
a,"int a = 2;"
func1,"var func1 = function(int x) returns int { int b = 23; a = a + 8; var func2 = function(int y) returns int { int c = 7; var func3 = function(int z) returns int { b = b + 1; return x + y + z + a + b + c; }; return func3(8) + y + x; }; return func2(4) + x; };"
rsaKeyArr,"byte[16] rsaKeyArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];"
keyFile,"string keyFile = \"../resources/private.key\";"
privateKey,"crypto:PrivateKey privateKey = check crypto:decodeRsaPrivateKeyFromKeyFile(keyFile);"
encryptedKeyFile,"string encryptedKeyFile = \"../resources/encrypted-private.key\";"
certFile,"string certFile = \"../resources/public.crt\";"
publicKey,"crypto:PublicKey publicKey = check crypto:decodeRsaPublicKeyFromCertFile(certFile);"
readDirResults,"file:MetaData[]|error readDirResults = file:readDir(\"foo\");"
participantEP,"http:Client participantEP = checkpanic new (\"http:"
price,"float price = 100.00;"
bizReq,"json bizReq = {symbol: \"GOODS\", price: price};"
req,"http:Request req = new;"
result,"var result = participantEP->post(\"\", req);"
accountNotFoundError,"AccountNotFoundError accountNotFoundError = error AccountNotFoundError(\"ACCOUNT_NOT_FOUND\", accountID = accountID);"
fields,"string[] fields = [];"
response,"string response = <string>checkpanic httpClient->get(\"/v4/?expr=2*3\", targetType = string);"
response,"string response = <string>checkpanic httpClient->get(\"/v4/?expr=9*4\", targetType = string);"
result,"record { int w1; int w2; } result = wait {w1, w2};"
helloString,"handle helloString = java:fromString(\"Hello world\");"
arrayDeque,"var arrayDeque = newArrayDeque();"
e,"boolean|error e = trap offer(arrayDeque, java:createNull());"
csvch,"io:WritableCSVChannel csvch = check io:openWritableCsvFile(\"\");"
recIndex,"int recIndex = 0;"
recLen,"int recLen = 0;"
result1,"[string[], string[]] result1 = getFields(<map<json>>content[recIndex]);"
marks,"map<int> marks = {sam: 50, jon: 60};"
modifiedMarks,"map<int> modifiedMarks = marks.entries().map(function ([string, int] pair) returns int { var [name, score] = pair; io:println(io:sprintf(\"%s scored: %d\", name, score)); return score + 10; } );"
allMarks,"map<int> allMarks = {physics: 100, ...modifiedMarks, chemistry: 75};"
xmlValue,"xml<never> xmlValue = <xml<never>> 'xml:concat();"
someMap,"map<never> someMap = {};"
detailTable,"table<Details> key<never> detailTable = table [ {name: \"John\", id: 23}, {name: \"Paul\", id: 25} ];"
d1,"Details d1 = { name: \"Martin\", id: 1990 };"
d2,"Details d2 = { name: \"Michelle\", id: 2001};"
detailList,"Details[] detailList = [d1, d2];"
reportList,"any[] reportList = from var detail in detailList where detail.id >= 2.0 let string degreeName = \"Bachelor of Medicine\", int graduationYear = 1990 order by detail.name descending limit 2 select { name: detail.name, degree: degreeName, graduationYear: graduationYear };"
onConflictError,"error onConflictError = error(\"Key Conflict\", message = \"cannot insert report\");"
d3,"any|error d3 = table key(id) from var detail in detailList select { id: detail.id } on conflict onConflictError;"
index,"int index = 0;"
moduleString,"string moduleString = \"Module(s): \" + \", \".'join(...modules);"
i,"int i = age;"
formattedCoordinates,"string[] formattedCoordinates = [];"
fileReadJson,"json fileReadJson = check io:fileReadJson(\"inputFile\");"
fillupEntries,"FillUpEntry[] fillupEntries = check fileReadJson.cloneWithType();"
sortedInput,"FillUpEntry[] sortedInput = fillupEntries.sort(array:ASCENDING, isolated function(FillUpEntry value) returns int => value.employeeId );"
baseTestDir,"string baseTestDir = check file:joinPath(baseDir, testDir);"
transformedTestDir,"string transformedTestDir = check file:joinPath(transformedDir, testDir);"
skipped,"TestDiffResult[] skipped = [];"
changed,"TestDiffResult[] changed = [];"
unchanged,"TestDiffResult[] unchanged = [];"
baseTestFile,"string baseTestFile = check file:joinPath(baseTestDir, test);"
transformedTestFile,"string transformedTestFile = check file:joinPath(transformedTestDir, test);"
baseTests,"TestCase[] baseTests = check parseTests(baseTestFile);"
transformedTests,"TestCase[] transformedTests = check parseTests(transformedTestFile);"
lines,"string[] lines = check io:fileReadLines(path);"
content,"string[] content = [];"
description,"string description = \"\";"
tests,"TestCase[] tests = [];"
s,"State s = CONTENT;"
baseIndex,"int baseIndex = 0;"
transformedIndex,"int transformedIndex = 0;"
baseDescription,"var { description: baseDescription, content: baseContent } = baseTests[baseIndex];"
baseContent,"var { description: baseDescription, content: baseContent } = baseTests[baseIndex];"
transformedDescription,"var { description: transformedDescription, content: transformedContent } = transformedTests[transformedIndex];"
transformedContent,"var { description: transformedDescription, content: transformedContent } = transformedTests[transformedIndex];"
body,"string[] body = [];"
currentPath,"string currentPath = \"\";"
path,"string path = diff.base.path;"
parts,"string[] parts = check file:splitPath(absPath);"
newContent,"string[] newContent = [\"import ballerina/io;\"];"
newLabels,"string[] newLabels = [];"
initFunc,"string initFunc = \"function init()\";"
newLine,"string newLine;"
starIndex,"int? starIndex = line.indexOf(\"{\");"
endIndex,"int? endIndex = line.indexOf(\"}\");"
targetIndex,"int targetIndex = <int>line.indexOf(\"?;\");"
i,"int? i = s.indexOf(\":\");"
fieldName,"string fieldName = s.substring(0, i);"
fieldValue,"string fieldValue = s.substring(i + 1);"
labels,"string[] labels = [];"
skipped,"int skipped = 0;"
skipIndices,"int[] skipIndices = skipTest.hasKey(filename) ? skipTest.get(filename) : [];"
skipTest,"boolean skipTest = false;"
outputFileName,"string outputFileName = string `./tests/${dir}/${filename}`;"
invalid,"boolean invalid = true;"
aliasName,"string aliasName = self.escapeGlobalIdent(name);"
alias,"ConstPointerValue alias = new (pointerType(aliasTy, props.addressSpace), \"@\" + aliasName);"
varName,"string varName = escapeIdent(name);"
out,"Output out = new;"
words,"string[] words = [\"target\", \"triple\", \"=\", \"\\"\", <TargetTriple>self.target, \"\\"\"];"
line,"string[] line = [alias.operand, \"=\"];"
words,"string[] words = [];"
initializer,"var initializer = prop.initializer;"
metadata,"Metadata metadata = new(self.genMetadataLabel());"
attrib,"ReturnEnumAttribute attrib = attribute[1];"
attrib,"ParamEnumAttribute attrib = attribute[1];"
paramIndex,"int paramIndex = attribute[0];"
paramType,"final Type paramType = functionType.paramTypes[i];"
register,"string register = \"%\" + i.toString();"
arg,"Value arg = new (paramType, register);"
isFirst,"boolean isFirst = true;"
bbName,"string|Unnamed bbName = self.genName(name);"
bb,"BasicBlock bb = new (self.context, bbName, self);"
varName,"string varName = name;"
count,"int count = self.variableNames.get(varName);"
newName,"string newName = varName + \".\" + count.toString();"
varName,"int varName = self.unnamedLabelCount;"
reg,"string|Unnamed reg = self.genName(name);"
newLabel,"string newLabel = self.nameCounter.toString();"
newName,"string newName = \"%\" + self.nameCounter.toString();"
newName,"string newName = self.nameTranslation[name];"
metadata,"Metadata metadata = self.m.addMetadata();"
body,"string[] body = [metadata.ref(), \"=\", \"!\", \"DIDerivedType\", \"(\", \"tag\", \":\", \"DW_TAG_pointer_type\"];"
name,"string? name = props.name;"
alignInBits,"Alignment? alignInBits = props.alignInBits;"
body,"string[] body = [metadata.ref(), \"=\", \"!\", \"DIDerivedType\", \"(\", \"tag\", \":\", \"DW_TAG_typedef\", \",\", \"name\", \":\", \"\\"\", name, \"\\"\", \",\", \"scope\", \":\", scope.ref(), \",\", \"file\", \":\", file.ref()];"
encodingToString,"string encodingToString = \"DW_ATE_\" + props.encoding;"
align,"int? align = props.alignInBits;"
words,"(string|Unnamed)[] words = [\"call\", \"void\", \"@llvm.dbg.value\", \"(\", \"metadata\", typeToString(props.value.ty, self.context), props.value.operand, \",\", \"metadata\", props.varInfo.ref(), \",\", \"metadata\", props.expr.ref(), \")\"];"
words,"(string|Unnamed)[] words = [\"call\", \"void\", \"@llvm.dbg.declare\", \"(\", \"metadata\", typeToString(props.value.ty, self.context), props.value.operand, \",\", \"metadata\", props.varInfo.ref(), \",\", \"metadata\", props.expr.ref(), \")\"];"
scope,"Metadata? scope = props.scope;"
file,"Metadata? file = props.file;"
ty,"Metadata? ty = props.ty;"
flags,"string[] flags = [];"
retainedNodes,"Metadata retainedNodes = self.m.addMetadata();"
words,"string[] words = [metadata.ref(), \"=\", \"distinct\", \"!\", \"DILexicalBlock\", \"(\", \"scope\", \":\", scope.ref(), \",\", \"file\", \":\", file.ref()];"
typeNode,"Metadata typeNode = self.m.addMetadata();"
words,"string[] words = [metadata.ref(), \"=\", \"!\", \"DILocation\", \"(\"];"
bb,"BasicBlock bb = self.bb();"
reg,"string|Unnamed reg = bb.func.genReg(name);"
ptrTy,"PointerType ptrTy = pointerType(ty);"
ty,"Type ty = ptr.ty.pointsTo;"
ty,"IntType|FloatType ty = sameNumberType(lhs, rhs);"
ty,"IntegralType ty = sameIntegralType(lhs, rhs);"
words,"(string|Unnamed)[] words = [reg, \"=\"];"
valueType,"Type valueType = val.ty;"
valTy,"Type valTy = val.ty;"
insnWords,"(string|Unnamed)[] insnWords;"
retType,"RetType retType;"
fnTy,"Type fnTy = fn.ty.pointsTo;"
fnName,"var fnName = fn.operand;"
functionName,"string functionName = \"@\" + fn.functionName;"
words,"(string|Unnamed)[] words = [reg];"
insnWords,"(string|Unnamed)[] insnWords = [];"
arg,"final Value arg = args[i];"
elementType,"Type elementType = getTypeAtIndex(<StructType>value.ty, index, self.context);"
condTy,"Type condTy = condition.ty;"
words,"(string|Unnamed)[] words = [];"
destTy,"PointerType destTy = gepArgs(words, ptr, indices, inbounds, self.context);"
tem,"BasicBlock? tem = self.currentBlock;"
chunks,"(string|Unnamed)[] chunks = [];"
currentChunk,"string[] currentChunk = [];"
newLines,"(string|Unnamed)[][] newLines = [];"
newLine,"(string|Unnamed)[] newLine = [];"
newLine,"string[] newLine = [];"
outputLine,"string outputLine = createLine([concat(...newLine)], INDENT);"
ty1,"Type ty1 = v1.ty;"
ty2,"Type ty2 = v2.ty;"
tyName,"string? tyName = ty.name;"
elementTypes,"Type[] elementTypes = ty.elementTypes;"
typeStringBody,"string[] typeStringBody = [];"
elementType,"final Type elementType = elementTypes[i];"
paramType,"final Type paramType = ty.paramTypes[i];"
elementTypes,"Type[] elementTypes = ty.name == () ? ty.elementTypes : context.getNamedStructBody(ty);"
metadata,"Metadata? metadata = fn.metadata;"
ty,"final Type ty = fn.functionType.paramTypes[i];"
lastTail,"string lastTail = parts.length() > 0 ? parts[parts.length() - 1] : \"\";"
head,"string head = word.length() > 0 ? word.substring(0, 1) : \"\";"
escaped,"string escaped = \"\\"\";"
cp,"int cp = ch.toCodePointInt();"
bytes,"byte[] bytes = ch.toBytes();"
result,"string result = \"\";"
hex,"string hex = cp.toHexString().toUpperAscii();"
ptrTy,"Type ptrTy = ptr.ty;"
resultType,"Type resultType = ptr.ty;"
resultAddressSpace,"int resultAddressSpace = 0;"
i,"int i;"
indexTy,"Type indexTy = index.ty;"
result,"string result = \"c\\"\";"
hex,"string hex = b.toHexString().toUpperAscii();"
endPos,"Position endPos = tok.previousEndPos();"
endPos,"Position endPos = tok.currentEndPos();"
valueExpr,"SimpleConstExpr valueExpr = check parseSimpleConstExpr(tok);"
td,"TypeDesc td = check parseTypeDesc(tok);"
startPos,"Position startPos = tok.currentStartPos();"
params,"FunctionTypeParam[] params = namedParams ?: [];"
paramStartPos,"Position paramStartPos = tok.currentStartPos();"
ret,"TypeDesc? ret = ();"
t,"Token? t = tok.current();"
namePos,"Position namePos = tok.currentStartPos();"
name,"string name = check tok.expectIdentifier();"
members,"TypeDesc[] members = [];"
rest,"TypeDesc? rest = ();"
fields,"FieldDesc[] fields = [];"
fieldStartPos,"Position fieldStartPos = tok.currentStartPos();"
ro,"boolean ro = false;"
opt,"boolean opt = false;"
endPos,"Position endPos = check tok.expectEnd(\";\");"
expr,"IntLiteralExpr expr = { startPos, endPos, base: 10, digits: t[1] };"
expr,"FpLiteralExpr expr = { startPos, endPos, untypedLiteral: t[1], typeSuffix: t[2] };"
expr,"IntLiteralExpr expr = { startPos, endPos, base: 16, digits: t[1] };"
expr,"LiteralExpr expr = { startPos, endPos, value: t[1] };"
expr,"LiteralExpr expr = { startPos, endPos, value: () };"
expr,"Expr expr = check parseExpr(tok);"
expr,"LiteralExpr expr = { startPos, endPos, value: t == \"true\" };"
kwPos,"Position kwPos = tok.currentStartPos();"
message,"Expr message = check parseExpr(tok);"
fields,"Field[] fields = check parseFields(tok);"
opPos,"Position opPos = tok.currentStartPos();"
index,"Expr index = check parseExpr(tok);"
accessEndPos,"Position accessEndPos = check tok.expectEnd(\"]\");"
accessExpr,"MemberAccessExpr accessExpr = { startPos, endPos: accessEndPos, opPos, container: expr, index };"
qnamePos,"Position qnamePos = tok.currentStartPos();"
name,"string name = check parseIdentifierOrMethodName(tok);"
fieldAccessExpr,"FieldAccessExpr fieldAccessExpr = { startPos, endPos, opPos, container: expr, fieldName: name };"
openParenPos,"Position openParenPos = tok.currentStartPos();"
exprs,"Expr[] exprs = [];"
closeTerminatorPos,"Position closeTerminatorPos = tok.currentStartPos();"
fields,"Field[] fields = [];"
f,"Field f = check parseField(tok);"
isIdentifier,"boolean isIdentifier = t[0] == IDENTIFIER;"
name,"string name = t[1];"
colonPos,"Position colonPos = tok.currentStartPos();"
value,"Expr value = check parseExpr(tok);"
f,"Field f = { startPos, endPos, colonPos, name, value, isIdentifier };"
operand,"NumericLiteralExpr operand = check parseNumericLiteralExpr(tok);"
expr,"SimpleConstNegateExpr expr = { startPos, endPos, opPos, operand };"
expr,"LiteralExpr expr = { startPos, endPos, value };"
endPos,"Position endPos = check tok.expectEnd(\")\");"
expr,"IntLiteralExpr expr = { startPos, endPos, base: 10, digits };"
expr,"IntLiteralExpr expr = { startPos, endPos, base: 16, digits };"
fragment,"string fragment = self.fragments[self.fragmentIndex];"
scannedLine,"ScannedLine scannedLine = self.lines[self.lineIndex];"
t,"Token? t = self.curTok;"
msg,"d:Message msg;"
pos,"Position pos = self.currentEndPos();"
pos,"Position pos = self.currentStartPos();"
scannedLine,"ScannedLine scannedLine = self.lines[self.lineIndex - 1];"
startPos,"Position startPos;"
endPos,"Position? endPos;"
line,"ScannedLine line = self.scannedLine(startLineNum);"
lineFragments,"string[] lineFragments = scanLineFragments(line);"
lineContent,"string lineContent = \"\".'join(...lineFragments);"
endColumnNum,"int endColumnNum;"
endLineNum,"int endLineNum;"
line,"ScannedLine line = self.scannedLine(lineNum);"
endColumnNum,"int endColumnNum = qualifiedIdentifierEndCodePointIndex(line, startColumnNum);"
fragments,"string[] fragments = line.fragments;"
fragCodes,"FragCode[] fragCodes = line.fragCodes;"
endCodePointIndex,"int endCodePointIndex = startCodePointIndex;"
fragmentIndex,"int fragmentIndex = fragmentCountUpTo(fragments, startCodePointIndex);"
nCodePoints,"int nCodePoints = 0;"
fragmentIndex,"int fragmentIndex = 0;"
nFragments,"int nFragments = fragments.length();"
fragCode,"FragCode fragCode = fragCodes[fragmentIndex];"
sources,"SingleStringTokenizerTestCase[] sources = [ [\"E\", string`\"`], [\"E\", \"'\"], [\"E\", \"`\"], [\"E\", string`\"\\"`], [\"E\", string`\"\a\"`], [\"E\", string`\`], [\"E\", string`\"${ \"\n\" }\"`], [\"E\", string`\"${ \"\r\" }\"`], [\"E\", string`\"\\`], [\"E\", string`\"\u{}\"`], [\"E\", \"\\"\\\" + \"u{D800}\\"\"], [\"E\", \"\\"\\\" + \"u{DFFF}\\"\"], [\"E\", \"\\"\\\" + \"u{110000}\\"\"], [\"E\", string`\"\u{X}\"`], [\"E\", string`\"\u{-6A}\"`], [\"E\", string`\"\u\"`], [\"E\", string`\"\u{\"`], [\"E\", string`\"\u{0\"`] ];"
tests,"map<TokenizerTestCase> tests = {};"
tests,"map<ParserTestCase> tests = {};"
testData,"ParserTestJson[] testData = check (check io:fileReadJson(\"modules/front.syntax/tests/data/testParser.json\")).fromJsonWithType();"
expected,"string[] expected;"
subject,"string subject = s[2];"
subjectLines,"string[] subjectLines = splitIntoLines(subject);"
rule,"string rule = s[1];"
testFiles,"var testFiles = check file:readDir(\"modules/front.syntax/tests/data\");"
path,"string path = f.absPath;"
base,"string base = check file:basename(path);"
src,"string[] src = check readCase(path);"
parentDir,"string parentDir = check file:parentPath(path);"
canonFile,"string canonFile = check file:joinPath(parentDir, canonFileName(base));"
baseParts,"[Kind, string] baseParts = check splitTestName(base);"
rule,"string rule = baseParts[1];"
len,"int len = base.length();"
kindPos,"int kindPos = base.indexOf(\"-\") ?: 0;"
kind,"string kind = base.substring(0, kindPos);"
afterKindPos,"int afterKindPos = min(kindPos + 1, len);"
rulePos,"int rulePos = base.indexOf(\"-\", afterKindPos) ?: afterKindPos;"
rule,"string rule = base.substring(afterKindPos, rulePos);"
caseLines,"string[] caseLines = [];"
inCase,"boolean inCase = false;"
indented,"int indented = 0;"
trimLine,"string trimLine = line.trim();"
sansExt,"string sansExt = base.substring(0, base.length() - SOURCE_EXTENSION.length());"
line,"ScannedLine line = file.scannedLine(lineIndex);"
lineContent,"string lineContent = \"\".'join(...scanLineFragments(line));"
rest,"string rest = lineContent.substring(isEndPos ? columnIndex - 1 : columnIndex);"
fields,"t:Field[] fields = [];"
f,"t:Field f = check parseField(tc, b, jlist[i], pathAppend(parent, i));"
ty,"t:SemType ty = check parseType(tc, b, j[1], pathAppend(path, 1));"
s,"t:SemType[] s = [];"
t,"t:SemType t = check parseType(tc, b, js[i], pathAppend(parent, i));"
result,"t:SemType result = binary(v[0], v[1]);"
i,"int? i = path.lastIndexOf(\"/\");"
filename,"string filename = i == () ? path : path.substring(i + 1);"
onPanic,"bir:Label? onPanic = block.onPanic;"
blockPanic,"readonly & BlockPanic blockPanic = onPanic == () ? [\"no-panic\"] : [\"on-panic\", formLabel(sc, onPanic)];"
insns,"(Insn & readonly|Position & readonly)[] insns = [];"
func,"bir:FunctionRef func = insn.func;"
ref,"FunctionRef ref = fromFunctionRefAccum(sc, func);"
args,"(Operand & readonly)[] args = from var arg in insn.args select fromOperand(sc, arg);"
entires,"MapEntry[] entires = [];"
preds,"TypeMergePred[] preds = [];"
insnSexpr,"sexpr:Data[] insnSexpr = [INSN_NAMES_SEXPR.get([insn.name, insn?.op]).sexpr];"
result,"bir:Register? result = insn?.result;"
operand,"bir:Operand? operand = insn?.operand;"
operands,"bir:Operand[]? operands = insn?.operands;"
value,"t:SingleValue value = op.value;"
ib,"int|boolean ib = value;"
symbol,"bir:Symbol symbol = funcRef.symbol;"
identifier,"string identifier = symbol.identifier;"
id,"ModuleId & readonly id = formModuleId(symbol.module);"
decls,"ModuleDeclsMemo decls = addGetModDecls(sc, id);"
existing,"ModuleDeclsMemo? existing = sc.decls[id];"
newDecl,"ModuleDeclsMemo newDecl = { id };"
params,"readonly & ts:Type[] params = from var t in sig.paramTypes select fromType(sc, t).cloneReadOnly();"
ret,"readonly & ts:Type ret = fromType(sc, sig.returnType);"
result,"IdNames result = table[];"
names,"map<true> names = {};"
maybeId,"string maybeId = names.hasKey(srcName) ? id.toString() : \"\";"
name,"string name = prefix + maybeId + \".\" + srcName;"
sexprAtoms,"t:AtomTableSexpr sexprAtoms = map from var [name, atom] in namedAtoms select [name.s, atom];"
atoms,"t:AtomTable atoms = t:atomTableFromSexpr(env, sexprAtoms);"
vFilesByName,"map<VirtualFile> vFilesByName = map from var [i, f] in files.enumerate() select [f[0].s, new(i, f[1].s, f.length() > 2 ? f[2].s : ())];"
funcDefns,"bir:FunctionDefn[] funcDefns = [];"
internalFuncDecl,"map<bir:FunctionSignature> internalFuncDecl = {};"
funcCodes,"FunctionCode[] funcCodes = [];"
paramTypes,"readonly & t:SemType[] paramTypes = from var t in params select t:fromSexpr(env, atoms, t);"
signature,"bir:FunctionSignature signature = { returnType: t:fromSexpr(env ,atoms, ret), paramTypes, restParamType: () };"
extFuncDecl,"ExternalFuncDecls extFuncDecl = table[];"
paramTypes,"readonly & t:SemType[] paramTypes = from var p in params select t:fromSexpr(env ,atoms, p);"
pc,"ParseContext pc = { tc, atoms, extFuncDecl, internalFuncDecl };"
vFiles,"VirtualFile[] vFiles = from var f in vFilesByName order by f.partIndex() select f;"
mod,"VirtualModule mod = new(pc, modId, funcDefns.cloneReadOnly(), funcCodes, vFiles);"
regMap,"map<bir:Register> regMap = {};"
regList,"bir:Register[] regList = [];"
regIndex,"int regIndex = 0;"
blockLabels,"map<bir:Label> blockLabels = {};"
label,"bir:Label label = 0;"
birBlocks,"bir:BasicBlock[] birBlocks = [];"
label,"int label = 0;"
insns,"bir:Insn[] insns = [];"
pos,"Position? pos = ();"
scope,"bir:RegisterScope scope = { scope: (), startPos: 0, endPos: 0 };"
pos,"bir:Position pos = 0;"
name,"string name = toMaybeName(nameSexpr) ?: \"_\";"
semType,"t:SemType semType = toSemType(pc, semTypeSexpr);"
underlying,"bir:Register? underlying = prevRegs[underlyingName];"
name,"string? name = toMaybeName(nameSexpr);"
dotPos,"int? dotPos = name.indexOf(\".\");"
pos,"bir:Position pos = posSexpr != () ? createPosition(posSexpr[1], posSexpr[2]) : 0;"
symbol,"bir:Symbol symbol = symbolFromSexpr(<FunctionRef>symbolSexpr);"
fieldNames,"string[] fieldNames = [];"
operands,"bir:Operand[] operands = [];"
fieldOperandsTyped,"[sexpr:String, Operand][] fieldOperandsTyped = checkpanic fieldOperands.cloneWithType();"
operandsWithType,"Operand[] operandsWithType = checkpanic operands.cloneWithType();"
operands,"bir:Register[] operands = [];"
predecessors,"bir:Label[] predecessors = [];"
predOperandsTyped,"[sexpr:Symbol, Label][] predOperandsTyped = checkpanic predOperands.cloneWithType();"
name,"var { bir: name, op } = INSN_NAMES_BIR_OP.get(insnSexpr[0]);"
insn,"BirInsnBase? insn = ();"
args,"readonly & bir:Operand[] args = from var arg in argsSexpr select toOperand(pc, arg);"
result,"var result = toResultRegister(pc, resultSexpr);"
erasedSignature,"bir:FunctionSignature erasedSignature = lookupSignature(pc, symbol);"
signature,"bir:FunctionSignature signature;"
module,"bir:ModuleId module = { org: org.s, names: [nameFirst.s, ...from var { s } in nameRest select s] };"
signature,"bir:FunctionSignature signature = lookupSignature(pc, symbol);"
env,"t:Env env = pc.tc.env;"
d,"t:FunctionDefinition d = new(env);"
semType,"t:SemType semType = d.define(env, t:defineListTypeWrapped(new(), env, signature.paramTypes, rest= signature.restParamType ?: t:NEVER, mut=t:CELL_MUT_NONE), signature.returnType);"
names,"readonly & [string, string...] names = [first.s, ...from var { s } in rest select s];"
length,"int length = fieldNames.length();"
requiredFieldNames,"string[] requiredFieldNames = mat.names;"
nRequiredFields,"int nRequiredFields = requiredFieldNames.length();"
requiredFieldIndex,"map<int> requiredFieldIndex = {};"
mappingReg,"bir:Register mappingReg = insn.operands[0];"
keyOperand,"bir:StringOperand keyOperand = insn.operands[1];"
fieldIndex,"int? fieldIndex = mappingFieldIndex(scaffold.typeContext(), mappingReg.semType, keyOperand);"
fill,"boolean fill;"
rf,"RuntimeFunction rf;"
k,"llvm:Value k;"
mapping,"llvm:Value mapping = builder.load(scaffold.address(mappingReg));"
memberWithErr,"llvm:Value memberWithErr = buildRuntimeFunctionCall(builder, scaffold, rf, [mapping, k]);"
member,"llvm:Value member = fill ? buildCheckPanicCode(builder, scaffold, memberWithErr, insn.pos) : memberWithErr;"
resultType,"t:SemType resultType = insn.result.semType;"
mat,"t:MappingAtomicType? mat = t:mappingAtomicType(tc, mappingType);"
peResult,"t:SemType peResult = t:intersect(resultType, POTENTIALLY_EXACT);"
lat,"t:ListAtomicType? lat = t:listAtomicType(tc, listType);"
ty,"t:SemType ty = t:intersect(semType, within);"
mappingType,"bir:SemType mappingType = mappingReg.semType;"
tc,"t:Context tc = scaffold.typeContext();"
newMemberOperand,"bir:Operand newMemberOperand = insn.operands[2];"
memberType,"t:SemType memberType = t:mappingMemberTypeInnerVal(scaffold.typeContext(), mappingType, keyOperand.semType);"
err,"llvm:Value err = buildRuntimeFunctionCall(builder, scaffold, rf, [ builder.load(scaffold.address(mappingReg)), k, check buildWideRepr(builder, scaffold, newMemberOperand, REPR_ANY, memberType) ]);"
k,"string? k = t:singleStringShape(keyOperand.semType);"
rf,"RuntimeFunction rf = overloadsExactBit(sourceType) ? taggedMemberClearExactAnyFunction : taggedMemberClearExactPtrFunction;"
continueBlock,"llvm:BasicBlock continueBlock = scaffold.addBasicBlock();"
errorBlock,"llvm:BasicBlock errorBlock = scaffold.addBasicBlock();"
valueToExactify,"llvm:PointerValue? valueToExactify = ();"
hasType,"llvm:Value hasType;"
baseRepr,"BaseRepr baseRepr = repr.base;"
tagged,"llvm:PointerValue tagged = <llvm:PointerValue>value;"
bitSet,"t:BasicTypeBitSet? bitSet = testTypeAsBasicBitSet(scaffold.typeContext(), operand.semType, semType);"
intConstraints,"t:IntSubtypeConstraints? intConstraints = t:intSubtypeConstraints(semType);"
sub,"t:BooleanSubtype sub = <t:BooleanSubtype>t:booleanSubtype(<t:ComplexSemType>semType);"
ifTrue,"llvm:BasicBlock ifTrue = scaffold.basicBlock(insn.ifTrue);"
ifFalse,"llvm:BasicBlock ifFalse = scaffold.basicBlock(insn.ifFalse);"
sourceReg,"var sourceReg = register.underlying;"
sourceRepr,"var sourceRepr = scaffold.getRepr(sourceReg);"
value,"var value = builder.load(scaffold.address(sourceReg));"
semType,"t:SemType semType = register.semType;"
narrowed,"llvm:Value narrowed = check buildNarrowRepr(builder, scaffold, sourceRepr, value, scaffold.getRepr(register));"
unnarrowed,"bir:Register unnarrowed = bir:unnarrow(insn.operands[0]);"
semType,"t:SemType semType = insn.result.semType;"
narrowed,"llvm:Value narrowed = check buildNarrowRepr(builder, scaffold, sourceRepr, value, scaffold.getRepr(insn.result));"
sourceBaseRepr,"BaseRepr sourceBaseRepr = sourceRepr.base;"
targetBaseRepr,"BaseRepr targetBaseRepr = targetRepr.base;"
bitSet,"t:BasicTypeBitSet bitSet = t:widenToBasicTypes(targetType);"
btCode,"t:BasicTypeCode? btCode = t:basicTypeCode(bitSet);"
lestSignificant,"llvm:ConstValue lestSignificant = context.constInt(\"i64\", leastSignificantVal);"
mostSignificant,"llvm:ConstValue mostSignificant = context.constInt(\"i64\", mostSignificantVal);"
ptr,"llvm:ConstPointerValue ptr = mod.addGlobal(llvm:arrayType(\"i64\", 2), decimalDefnSymbol(defnIndex), initializer = context.constArray(\"i64\", [lestSignificant, mostSignificant]), align = 8, isConstant = true, unnamedAddr = true, linkage = \"internal\");"
nBytes,"int nBytes = bytes.length();"
nBytesPadded,"int nBytesPadded = (((nBytes + headerSize + 7) >> 3) << 3) - headerSize;"
w,"t:BasicTypeBitSet w = t:widenToBasicTypes(ty);"
constraints,"t:IntSubtypeConstraints? constraints = t:intSubtypeConstraints(ty);"
repr,"IntRepr repr = { constraints, alwaysInImmediateRange: isIntConstrainedToImmediate(constraints) };"
supported,"int supported = t:NIL|t:BOOLEAN|t:INT|t:FLOAT|t:DECIMAL|t:STRING|t:LIST|t:MAPPING|t:ERROR|t:FUNCTION;"
maximized,"int maximized = w | supported;"
repr,"TaggedRepr repr = { subtype: w, alwaysImmediate: isSemTypeAlwaysImmediate(ty, w) };"
strSubtype,"t:StringSubtype|boolean strSubtype = t:stringSubtype(ty);"
bytes,"byte[] bytes = s.toBytes();"
ty,"llvm:StructType ty = llvm:structType([llvm:pointerType(buildFunctionSignature(signature))]);"
initValue,"llvm:ConstValue initValue = context.constStruct([func]);"
ptr,"llvm:ConstPointerValue ptr = mod.addGlobal(ty, functionDefnSymbol(defnIndex), initializer = initValue, align = 8, isConstant=true, unnamedAddr=true, linkage= \"internal\");"
result,"bir:Register result = insn.result;"
subtype,"t:BasicTypeBitSet subtype = lhsRepr.subtype | rhsRepr.subtype;"
orderTypeMinusNil,"t:BasicTypeBitSet orderTypeMinusNil = subtype & ~t:NIL;"
lhsType,"t:SemType lhsType = lhs.semType;"
rhsType,"t:SemType rhsType = rhs.semType;"
orderTypeMinusNilCode,"var orderTypeMinusNilCode = <t:BasicTypeCode>t:basicTypeCode(orderTypeMinusNil);"
compareFunc,"RuntimeFunction compareFunc = compareFunctions.get(orderTypeMinusNilCode).optCompareFunction;"
memberType,"t:BasicTypeBitSet memberType = 0;"
memberTypeCode,"t:BasicTypeCode? memberTypeCode = t:basicTypeCode(memberType);"
tcf,"TaggedCompareFunction? tcf = compareFunctions[memberTypeCode];"
atomic,"t:ListAtomicType? atomic = t:listAtomicType(tc, semType);"
bbExact,"llvm:BasicBlock bbExact = scaffold.addBasicBlock();"
bbInexact,"llvm:BasicBlock bbInexact = scaffold.addBasicBlock();"
bbJoin,"llvm:BasicBlock bbJoin = scaffold.addBasicBlock();"
isExact,"llvm:Value isExact = builder.iBitwise(\"and\", buildIsExact(builder, scaffold, lhs), buildIsExact(builder, scaffold, rhs));"
transform,"TaggedCompareResultTransform transform = taggedCompareResultTransforms.get(insn.op);"
result,"llvm:Value result = buildRuntimeFunctionCall(builder, scaffold, comparator, [lhs, rhs]);"
bbJoin,"llvm:BasicBlock bbJoin = buildCompareTaggedBasic(builder, scaffold, lhs, rhs, result);"
lhsUntagged,"llvm:Value lhsUntagged = buildUntagInt(builder, scaffold, <llvm:PointerValue>lhs);"
lhsUntagged,"llvm:Value lhsUntagged = buildUntagFloat(builder, scaffold, <llvm:PointerValue>lhs);"
lhsUntagged,"llvm:Value lhsUntagged = buildUntagBoolean(builder, <llvm:PointerValue>lhs);"
bbNil,"llvm:BasicBlock bbNil = scaffold.addBasicBlock();"
bbNotNil,"llvm:BasicBlock bbNotNil = scaffold.addBasicBlock();"
isNil,"llvm:Value isNil = builder.iCmp(\"eq\", lhs, scaffold.llContext().constNull(llvm:pointerType(\"i8\", 1)));"
diScope,"DIScope diScope = self.diBuilder.createLexicalBlock(parent.diScope, self.diFile, line, column);"
loc,"DILocation loc;"
noLineLoc,"DILocation? noLineLoc = self.noLineLocation;"
charMeta,"llvm:Metadata charMeta = diBuilder.createBasicType(name=\"char\", encoding=\"signed_char\", sizeInBits=8);"
emptyExpr,"llvm:Metadata emptyExpr = diScaffold.diBuilder.createExpression([]);"
scope,"Scope scope = addToParentScope(register.scope, register.pos, diScaffold.rootScope, diScaffold);"
tyMeta,"llvm:Metadata tyMeta = diScaffold.registerTypeToMetadata(register);"
childCount,"int childCount = parent.childScopes.length();"
addIndex,"int? addIndex = ();"
child,"Scope child = parent.childScopes[i];"
newScope,"Scope newScope = diScaffold.createScope(declPos, registerScope.endPos, parent, [child]);"
newScope,"Scope newScope = diScaffold.createScope(declPos, registerScope.endPos, parent, []);"
newChildScopes,"Scope[] newChildScopes = parent.childScopes.slice(0, addIndex);"
varMeta,"llvm:Metadata varMeta = diBuilder.createAutoVariable(ty=tyMeta, scope=diScope, name=register.name, lineNo=line, file=diFile);"
declLoc,"llvm:Metadata declLoc = diBuilder.createDebugLocation(line, column, diScope);"
intrinsicName,"llvm:IntrinsicFunctionName? intrinsicName = buildBinaryIntIntrinsic(insn.op);"
lhs,"llvm:Value lhs = buildInt(builder, scaffold, insn.operands[0]);"
rhs,"llvm:Value rhs = buildInt(builder, scaffold, insn.operands[1]);"
result,"llvm:Value result;"
joinBlock,"llvm:BasicBlock? joinBlock = ();"
intrinsicFunction,"llvm:FunctionDecl intrinsicFunction = scaffold.getIntrinsicFunction(intrinsicName);"
resultWithOverflow,"llvm:Value resultWithOverflow = <llvm:Value>builder.call(intrinsicFunction, [lhs, rhs]);"
overflowBlock,"llvm:BasicBlock overflowBlock = scaffold.addBasicBlock();"
zeroDivisorBlock,"llvm:BasicBlock zeroDivisorBlock = scaffold.addBasicBlock();"
op,"llvm:IntArithmeticSignedOp op;"
b,"llvm:BasicBlock b = scaffold.addBasicBlock();"
op,"llvm:IntArithmeticOp op = intArithmeticOps.get(insn.op);"
result,"llvm:Value result = builder.iArithmeticNoWrap(op, lhs, rhs);"
lhs,"llvm:Value lhs = buildFloat(builder, scaffold, insn.operands[0]);"
rhs,"llvm:Value rhs = buildFloat(builder, scaffold, insn.operands[1]);"
op,"llvm:FloatArithmeticOp op = floatArithmeticOps.get(insn.op);"
result,"llvm:Value result = builder.fArithmetic(op, lhs, rhs);"
lhs,"llvm:Value lhs = buildDecimal(builder, scaffold, insn.operands[0]);"
rhs,"llvm:Value rhs = buildDecimal(builder, scaffold, insn.operands[1]);"
resultWithErr,"llvm:Value resultWithErr = buildRuntimeFunctionCall(builder, scaffold, decimalArithmeticFuncs.get(insn.op), [lhs, rhs]);"
operand,"llvm:Value operand = buildFloat(builder, scaffold, insn.operand);"
result,"llvm:Value result = builder.fNeg(operand);"
op,"llvm:IntBitwiseOp op = binaryBitwiseOp.get(insn.op);"
result,"llvm:Value result = builder.iBitwise(op, lhs, rhs);"
resultWithErr,"llvm:Value resultWithErr = buildRuntimeFunctionCall(builder, scaffold, convertToIntFunction, [val]);"
resultWithErr,"llvm:Value resultWithErr = buildRuntimeFunctionCall(builder, scaffold, floatToIntFunction, [floatVal]);"
resultWithErr,"llvm:Value resultWithErr = buildRuntimeFunctionCall(builder, scaffold, decimalToIntFunction, [decimalVal]);"
errBlock,"llvm:BasicBlock errBlock = scaffold.addBasicBlock();"
result,"llvm:Value result = buildRuntimeFunctionCall(builder, scaffold, convertToFloatFunction, [val]);"
result,"llvm:Value result = buildRuntimeFunctionCall(builder, scaffold, decimalToFloatFunction, [decimalVal]);"
resultWithErr,"llvm:Value resultWithErr = buildRuntimeFunctionCall(builder, scaffold, convertToDecimalFunction, [val]);"
resultWithErr,"llvm:Value resultWithErr = buildRuntimeFunctionCall(builder, scaffold, decimalFromFloatFunction, [floatVal]);"
operand,"llvm:Value operand = buildDecimal(builder, scaffold, insn.operand);"
result,"llvm:Value result = buildRuntimeFunctionCall(builder, scaffold, decimalNegFunction, [operand]);"
op,"CmpEqOp op = insn.op[0] == \"!\" ? \"ne\" : \"eq\";"
exact,"boolean exact = insn.op.length() == 3;"
floatTagBlock,"llvm:BasicBlock floatTagBlock = scaffold.addBasicBlock();"
otherTagBlock,"llvm:BasicBlock otherTagBlock = scaffold.addBasicBlock();"
joinBlock,"llvm:BasicBlock joinBlock = scaffold.addBasicBlock();"
eqFunc,"RuntimeFunction eqFunc = exact ? floatExactEqFunction : floatEqFunction;"
b,"llvm:Value b = buildRuntimeFunctionCall(builder, scaffold, eqFunc, [lhsValue, rhsValue]);"
str,"string str = operand.value;"
bytes,"byte[] bytes = str.toBytes();"
intTagBlock,"llvm:BasicBlock intTagBlock = scaffold.addBasicBlock();"
func,"RuntimeFunction func = exact ? exactEqFunction : eqFunction;"
b,"llvm:Value b = buildRuntimeFunctionCall(builder, scaffold, func, [tagged1, tagged2]);"
b,"llvm:Value b = buildRuntimeFunctionCall(builder, scaffold, stringEqFunction, [tagged1, tagged2]);"
b,"llvm:Value b;"
signature,"bir:FunctionSignature signature = { returnType, paramTypes: paramTypes.cloneReadOnly(), restParamType };"
args,"llvm:Value[] args = check buildFunctionCallArgs(builder, scaffold, paramTypes, paramTypes, from int i in 1 ..< insn.operands.length() select insn.operands[i]);"
fnStructPtrTy,"llvm:PointerType fnStructPtrTy = llvm:pointerType(llvm:structType([llvm:pointerType(buildFunctionSignature(signature))]));"
fnStructTaggedPtr,"llvm:PointerValue fnStructTaggedPtr = <llvm:PointerValue>builder.load(scaffold.address(insn.operands[0]));"
unTaggedVal,"llvm:Value unTaggedVal = builder.iBitwise(\"and\", builder.ptrToInt(fnStructTaggedPtr, LLVM_INT), constInt(scaffold, POINTER_MASK));"
unTaggedPtr,"llvm:PointerValue unTaggedPtr = builder.getElementPtr(constNil(scaffold), [unTaggedVal], \"inbounds\");"
fnStructPtr,"llvm:PointerValue fnStructPtr = builder.bitCast(builder.addrSpaceCast(unTaggedPtr, LLVM_TAGGED_PTR_WITHOUT_ADDR_SPACE), fnStructPtrTy);"
fnGlobalPtr,"llvm:PointerValue fnGlobalPtr = builder.getElementPtr(fnStructPtr, [constIndex(scaffold, 0), constIndex(scaffold, 0)], \"inbounds\");"
funcPtr,"llvm:PointerValue funcPtr = <llvm:PointerValue>builder.load(fnGlobalPtr);"
retValue,"llvm:Value? retValue = buildFunctionCall(builder, scaffold, funcPtr, args);"
retRepr,"RetRepr retRepr = semTypeRetRepr(returnType);"
result,"llvm:Value? result = builder.call(fn, args);"
decl,"llvm:FunctionDecl? decl = scaffold.getImportedFunction(symbol);"
ty,"llvm:FunctionType ty = buildFunctionSignature(sig);"
mod,"llvm:Module mod = scaffold.getModule();"
d,"llvm:FunctionDecl d = mod.addFunctionDecl(mangleExternalSymbol(symbol), ty);"
value,"llvm:Value value = <llvm:Value>builder.call(scaffold.getRuntimeFunctionDecl(errorConstructFunction), [ check buildString(builder, scaffold, insn.operand), constInt(scaffold, scaffold.lineNumber(insn.pos)) ]);"
value,"llvm:Value value = buildRuntimeFunctionCall(builder, scaffold, stringConcatFunction, [ check buildString(builder, scaffold, insn.operands[0]), check buildString(builder, scaffold, insn.operands[1]) ]);"
subtypeArray,"llvm:ConstValue subtypeArray = cx.llContext().constArray(cx.llTypes.basicSubtypePtr, llSubtypes);"
initValue,"llvm:ConstValue initValue = cx.llContext().constStruct([constBitset(cx, all), constBitset(cx, someBits), subtypeArray]);"
llType,"llvm:StructType llType = llvm:structType([LLVM_BITSET, LLVM_BITSET, llvm:arrayType(cx.llTypes.basicSubtypePtr, llSubtypes.length())]);"
ptr,"llvm:ConstPointerValue ptr = cx.llMod.addGlobal(llType, symbol, initializer=initValue, isConstant=true, linkage=linkage);"
ptr,"llvm:ConstPointerValue ptr;"
existingDefn,"SubtypeDefn? existingDefn = cx.subtypeDefns[typeCode, semType];"
symbol,"string symbol = subtypeDefnSymbol(cx.subtypeDefns.length());"
init,"llvm:ConstValue? init = ();"
llStructTy,"llvm:StructType llStructTy;"
sub,"SubtypeStruct sub = createSubtypeStruct(cx, typeCode, semType);"
newDefn,"SubtypeDefn newDefn = { typeCode, semType, ptr, structType: cx.inherentTypesComplete ? () : llStructTy };"
structType,"llvm:StructType? structType = defn.structType;"
sub,"SubtypeStruct sub = createSubtypeStruct(cx, defn.typeCode, defn.semType);"
sub,"t:BooleanSubtype sub = <t:BooleanSubtype>t:booleanSubtype(semType);"
ranges,"t:IntSubtype ranges = <t:IntSubtype>t:intSubtype(semType);"
sub,"t:FloatSubtype sub = <t:FloatSubtype>t:floatSubtype(semType);"
len,"int len = sub.values.length();"
sub,"t:DecimalSubtype sub = <t:DecimalSubtype>t:decimalSubtype(semType);"
sub,"t:StringSubtype sub = <t:StringSubtype>t:stringSubtype(semType);"
strs,"string[] strs = [];"
strConsts,"llvm:ConstValue[] strConsts = from var s in strs.sort() select getInitString(cx, s);"
lat,"t:ListAtomicType? lat = t:listAtomicType(cx.tc, semType);"
rest,"t:SemType rest = t:cellInnerVal(lat.rest);"
mat,"t:MappingAtomicType? mat = t:mappingAtomicType(cx.tc, semType);"
rest,"t:SemType rest = t:cellInnerVal(mat.rest);"
fieldTypes,"t:BasicTypeBitSet[] fieldTypes = [];"
tyInner,"t:SemType tyInner = t:cellInner(ty);"
tids,"llvm:ConstValue[] tids = from var itd in cx.inherentTypeDefns[basic] where t:isSubtype(cx.tc, itd.semType, ty) select constTid(cx, itd.tid);"
llFieldType,"final llvm:StructType llFieldType = llvm:structType([LLVM_TAGGED_PTR, LLVM_BITSET]);"
nFields,"final int nFields = fieldNames.length();"
llFields,"llvm:ConstValue[] llFields = [];"
functionRefs,"FunctionRef[] functionRefs = [];"
prefix,"string prefix = listAtomicTypeToListReprPrefix(atomic);"
suffix,"string suffix = listDescFuncSuffixes[i];"
tentativeName,"string tentativeName = prefix + \"_\" + suffix;"
llType,"llvm:FunctionType llType = llListDescFuncTypes[i];"
ref,"FunctionRef ref;"
name,"string? name = tentativeName;"
existing,"llvm:FunctionDecl? existing = cx.typeTestFuncs[tk];"
decl,"llvm:FunctionDecl decl = cx.llMod.addFunctionDecl(mangleRuntimeSymbol(tk + \"_subtype_contains\"), cx.llTypes.subtypeContainsFunction);"
existingDecl,"llvm:FunctionDecl? existingDecl = cx.runtimeFuncs[symbol];"
newDecl,"llvm:FunctionDecl newDecl = cx.llMod.addFunctionDecl(symbol, llType);"
curDefn,"llvm:ConstPointerValue? curDefn = cx.stringDefns[str];"
newDefn,"llvm:ConstPointerValue newDefn = addStringDefn(cx.llContext(), cx.llMod, cx.stringDefns.length(), str);"
val,"llvm:ConstPointerValue val = addDecimalDefn(cx.llContext(), cx.llMod, cx.decimalCount, d);"
file,"DIFile file = mod.files[partIndex];"
low56,"var low56 = builder.iBitwise(\"and\", constInt(scaffold, (1 << TAG_SHIFT) - 1), value);"
tagged,"var tagged = builder.iBitwise(\"or\", constInt(scaffold, FLAG_IMMEDIATE | TAG_INT), low56);"
repr,"TaggedRepr repr = { subtype: t:FUNCTION, alwaysImmediate: false };"
value,"t:SingleValue value = operand.value;"
bytes,"byte[] bytes = value.toBytes();"
alwaysImmediate,"boolean alwaysImmediate = isSmallString(value.length(), bytes, nBytes);"
repr,"TaggedRepr repr = { subtype: t:STRING, alwaysImmediate };"
alwaysInImmediateRange,"boolean alwaysInImmediateRange = IMMEDIATE_INT_MIN <= value && value <= IMMEDIATE_INT_MAX;"
repr,"IntRepr repr = { constraints: { min: value, max: value, all: true }, alwaysInImmediateRange };"
func,"llvm:Function func;"
paramTypes,"llvm:Type[] paramTypes = from var ty in signature.paramTypes select (semTypeRepr(ty)).llvm;"
repr,"RetRepr repr = semTypeRetRepr(signature.returnType);"
ty,"llvm:FunctionType ty = { returnType: repr.llvm, paramTypes: paramTypes.cloneReadOnly() };"
masked,"llvm:Value masked = <llvm:Value>builder.call(scaffold.getIntrinsicFunction(\"ptrmask.p1.i64\"), [taggedPtr, constInt(scaffold, FLAG_EXACT)]);"
tests,"map<TestCase> tests = {};"
data,"json data = check io:fileReadJson(\"modules/comm.lib/tests/data/decimalTest.json\");"
testCases,"TestCase[] testCases = check data.fromJsonWithType();"
indices,"int[] indices = listSamples(cx, members, rest, neg);"
atom,"ListAtomicType atom = atoms[0];"
next,"ListAtomicType next = atoms[i];"
tmpAtom,"var tmpAtom = listIntersectWith(env, atom.members, atom.rest, next.members, next.rest);"
semType,"SemType semType = createBasicSemType(BT_LIST, bddAtom(env.listAtom(atom)));"
nt,"final ListAtomicType nt = cx.listAtomType(neg.atom);"
negLen,"int negLen = nt.members.fixedLength;"
len,"int len = memberTypes.length();"
t,"SemType[] t = memberTypes.slice(0, i);"
d,"SemType d = diff(memberTypes[i], listMemberAt(nt.members, nt.rest, indices[i]));"
t,"SemType[] t = memberTypes.clone();"
maxInitialLength,"int maxInitialLength = members.initial.length();"
fixedLengths,"int[] fixedLengths = [members.fixedLength];"
tem,"Conjunction? tem = neg;"
nNeg,"int nNeg = 0;"
lt,"ListAtomicType lt = cx.listAtomType(tem.atom);"
m,"FixedLengthArray m = lt.members;"
boundaries,"int[] boundaries = from int i in 1 ... maxInitialLength select i;"
indices,"int[] indices = [];"
lastBoundary,"int lastBoundary = 0;"
segmentLength,"int segmentLength = b - lastBoundary;"
nSamples,"int nSamples = int:min(segmentLength, nNeg);"
memberTypes,"CellSemType[] memberTypes = [];"
nRequired,"int nRequired = 0;"
index,"int index = indices[i];"
t,"CellSemType t = cellContainingInnerVal(cx.env, listMemberAt(members, rest, index));"
len1,"int len1 = members1.fixedLength;"
len2,"int len2 = members2.fixedLength;"
memberLen,"int memberLen = members.initial.length();"
i,"int i = int:min(index, memberLen - 1);"
m,"SemType m = NEVER;"
initLen,"int initLen = fixedArray.initial.length();"
fixedLen,"int fixedLen = fixedArray.fixedLength;"
m,"SemType m = cellInner(rest);"
applicable,"SemType[] applicable = [];"
ty,"SemType ty = memberTypes[i1];"
combined,"[Range, int?, int?][] combined = [];"
i1,"int i1 = 0;"
i2,"int i2 = 0;"
len1,"int len1 = ranges1.length();"
len2,"int len2 = ranges2.length();"
cur,"int cur = int:MIN_VALUE;"
next,"int? next = ();"
max,"int max = next == () ? int:MAX_VALUE : next - 1;"
in1,"int? in1 = ();"
r,"Range r = ranges1[i1];"
in2,"int? in2 = ();"
r,"Range r = ranges2[i2];"
combined,"[Range, int?, int?][] combined = combineRanges(range1, range2);"
i,"int i = r.max + 1;"
atomicType,"MappingAtomicType atomicType = { names: names.cloneReadOnly(), types: types.cloneReadOnly(), rest };"
atom,"Atom atom;"
rec,"RecAtom? rec = self.rec;"
bdd,"BddNode bdd = bddAtom(atom);"
s,"SemType s = basicSubtype(BT_MAPPING, bdd);"
cellFields,"CellField[] cellFields = from var { name, ty, ro, opt } in fields select [name, cellContaining(env, opt ? union(ty, UNDEF) : ty, ro ? CELL_MUT_NONE : mut)];"
restCell,"CellSemType restCell = cellContaining(env, union(rest, UNDEF), rest == NEVER ? CELL_MUT_NONE : mut);"
sortedFields,"CellField[] sortedFields = fields.sort(\"ascending\", fieldName);"
types,"CellSemType[] types = [];"
m,"var m = intersectMapping(cx.env, combined, cx.mappingAtomType(p.atom));"
neg,"MappingAtomicType neg = cx.mappingAtomType(negList.atom);"
pairing,"MappingPairing pairing = new (pos, neg);"
d,"CellSemType d = <CellSemType>diff(posType, negType);"
posTypes,"CellSemType[] posTypes = shallowCopyCellTypes(pos.types);"
types,"CellSemType[] types = shallowCopyCellTypes(m.types);"
atom,"MappingAtomicType atom = atoms[0];"
tmpAtom,"var tmpAtom = intersectMapping(env, atom, atoms[i]);"
semType,"SemType semType = createBasicSemType(BT_MAPPING, bddAtom(env.mappingAtom(atom)));"
t,"CellSemType t = intersectMemberSemTypes(env, type1, type2);"
rest,"CellSemType rest = intersectMemberSemTypes(env, m1.rest, m2.rest);"
p,"CellFieldPair p;"
memberType,"SemType? memberType = ();"
types,"SemType[] types = from CellSemType t in atomic.types select cellInner(t);"
rest,"SemType rest = cellInner(atomic.rest);"
memberTypes,"SemType[] memberTypes = [];"
coverage,"StringSubtypeListCoverage coverage = stringSubtypeListCoverage(key, atomic.names);"
pc,"SexprTypeParseContext pc = { env, atoms };"
ty,"SemType? ty = namedTypes[tySexpr];"
existingAtomTy,"SemType? existingAtomTy = pc.atoms[tySexpr];"
defn,"Definition? defn = pc.started[tySexpr];"
newAtomTy,"SemType newAtomTy = fromAtomSexpr(pc, tySexpr, pc.atomSexprs.get(tySexpr));"
result,"SemType result = NEVER;"
result,"SemType result = VAL;"
d,"FunctionDefinition d = new(pc.env);"
initial,"SemType[] initial = from var member in <ts:Type[]>args select fromSexprInternal(pc, member);"
argsTuple,"SemType argsTuple = defineListTypeWrapped(listDef, pc.env, initial, initial.length(), mut = CELL_MUT_NONE);"
d,"ListDefinition d = new;"
initial,"SemType[] initial = from var member in initialSexpr select fromSexprInternal(pc, member);"
rest,"SemType rest = fromSexprInternal(pc, restSexpr);"
d,"MappingDefinition d = new;"
fields,"Field[] fields = from var [fieldName, fieldTy] in fieldsSexpr select { name: fieldName.s, ty: fromSexprInternal(pc, fieldTy) };"
some,"int some = t.some;"
subtypeList,"BasicSubtype[] subtypeList = [];"
code,"var code = <BasicTypeCode>lib:numberOfTrailingZeros(some);"
loBits,"int loBits = t.some & (c - 1);"
all1,"BasicTypeBitSet all1;"
all2,"BasicTypeBitSet all2;"
some1,"BasicTypeBitSet some1;"
some2,"BasicTypeBitSet some2;"
all,"BasicTypeBitSet all = all1 | all2;"
some,"BasicTypeBitSet some = (some1 | some2) & ~<int>all;"
subtypes,"BasicSubtype[] subtypes = [];"
all,"BasicTypeBitSet all = all1 & all2;"
some,"BasicTypeBitSet some = (some1 | all1) & (some2 | all2);"
all,"BasicTypeBitSet all = all1 & ~<int>(all2 | some2);"
some,"BasicTypeBitSet some = (all1 | some1) & ~<int>all2;"
d2Complement,"SubtypeData d2Complement = complement(d2);"
subtypes,"BddNode[] subtypes = toBddSubtypes(cx, t);"
listSubtype,"boolean listSubtype = isSubtypeSimple(t, LIST);"
cyclic,"boolean cyclic = listSubtype ? listBddIsCyclic(cx, subtype) : mappingBddIsCyclic(cx, subtype);"
bits,"int bits;"
semType,"SemType semType = diff(union(t1, t2), NIL);"
nOrderings,"int nOrderings = lib:bitCount(widenToBasicTypes(semType));"
memoized,"ComparableMemo? memoized = cx.comparableMemo[t1, t2];"
memo,"ComparableMemo memo = { semType1: t1, semType2: t2 };"
members,"readonly & CellSemType[] members = atomic.members.initial;"
i,"int i = members.length();"
existing,"FillerMemo? existing = cx.fillerMemo[semType];"
memo,"FillerMemo memo = { semType, filler: () };"
f,"Filler? f = computeFiller(cx, semType);"
bitSet,"BasicTypeBitSet bitSet = widenToBasicTypes(t);"
value,"SingleValue value = ();"
wrapped,"WrappedSingleValue? wrapped = singleShape(t);"
mat,"MappingAtomicType? mat = mappingAtomicType(cx, t);"
lat,"ListAtomicType? lat = listAtomicType(cx, t);"
memberFillers,"Filler[] memberFillers = [];"
f,"Filler? f = filler(cx, cellInner(memberType));"
data,"SubtypeData data = intSubtypeWidenUnsigned(subtypeData(t, BT_INT));"
intSubtype,"var intSubtype = intSubtype(t);"
len,"int len = intSubtype.length();"
memberType,"SemType memberType = cellInnerVal(atomic.rest);"
ranges,"Range[] ranges = [];"
allRanges,"Range[] allRanges = bddListAllRanges(cx, <Bdd>getComplexSubtypeData(t, BT_LIST), []);"
m,"SemType m = listMemberTypeInnerVal(cx, t, intConst(r.min));"
listAtomicInner,"ListAtomicType listAtomicInner = LIST_ATOMIC_INNER;"
env,"Env env = cx.env;"
keyData,"IntSubtype|boolean keyData = intSubtype(k);"
indexIntType,"IntSubtype|boolean indexIntType;"
paths,"BddPath[] paths = [];"
alts,"ListAlternative[] alts = [];"
intersection,"var intersection = intersectListAtoms(cx.env, from var atom in pos select cx.listAtomType(atom));"
mappingAtomicInner,"MappingAtomicType mappingAtomicInner = MAPPING_ATOMIC_INNER;"
keyData,"StringSubtype|boolean keyData = stringSubtype(k);"
keyStringType,"StringSubtype|boolean keyStringType;"
alts,"MappingAlternative[] alts = [];"
intersection,"var intersection = intersectMappingAtoms(cx.env, from var atom in pos select cx.mappingAtomType(atom));"
cat,"CellAtomicType cat = <CellAtomicType>cellAtomicType(t);"
s,"BasicSubtype? s = singleBasicSubtype(t);"
value,"SingleValue value;"
semType,"ComplexSemType semType;"
numType,"SemType numType = intersect(semType, NUMBER);"
memo,"SemType? memo = context.jsonMemo;"
env,"Env env = context.env;"
j,"SemType j = union(SIMPLE_OR_STRING, union(listDef.getSemType(env), mapDef.getSemType(env)));"
memo,"SemType? memo = context.anydataMemo;"
tableTy,"SemType tableTy = tableContaining(env, mapDef.getSemType(env));"
ad,"SemType ad = union(union(SIMPLE_OR_STRING, union(XML, tableTy)), union(listDef.getSemType(env), mapDef.getSemType(env)));"
members,"SemType[] members = toMemberSemtypes(cx, ty);"
subtypes,"BddNode[] subtypes = toBddSubtypes(cx, ty);"
members,"SemType[] members = [];"
listSubtype,"boolean listSubtype = isSubtypeSimple(ty, LIST);"
atomicTy,"ListAtomicType atomicTy = cx.listAtomType(subtype.atom);"
atomicTy,"MappingAtomicType atomicTy = cx.mappingAtomType(subtype.atom);"
mappingSubtype,"boolean mappingSubtype = isSubtypeSimple(ty, MAPPING);"
result,"ts:Type[] result = [];"
allChars,"boolean allChars = char.values.length() == 0;"
posPrimitiveFlag,"int posPrimitiveFlag = xmlTy.primitives & ~extraAll;"
negPrimitiveFlag,"int negPrimitiveFlag = ~xmlTy.primitives & extraAll;"
pos,"ts:Type pos = joinTypeSexpr(\"|\", [...sequence, ...xmlPrimitivesToSexpr(posPrimitiveFlag)]);"
negPrimitives,"ts:Not negPrimitives = [\"!\", ...xmlPrimitivesToSexpr(negPrimitiveFlag)];"
disj,"ts:Type[] disj = [];"
extra,"int extra = 0;"
onlyNeg,"boolean onlyNeg = true;"
extraInPath,"int? extraInPath = ();"
conj,"ts:Type[] conj = [];"
extraInPos,"int extraInPos = <int>p | XML_PRIMITIVE_NEVER;"
extraInNeg,"int extraInNeg = ~<int>n & (XML_PRIMITIVE_ALL_MASK & ~XML_PRIMITIVE_NEVER);"
conjTy,"ts:Type conjTy = joinTypeSexpr(\"&\", conj);"
xmlPrimitives,"ts:Type[] xmlPrimitives = [];"
nonNeverPrimitives,"int nonNeverPrimitives = flag & ~XML_PRIMITIVE_NEVER;"
rwAndRo,"int rwAndRo = ((flags & 0xe0) >> 3) & flags;"
mask,"int mask = (rwAndRo << 3) | rwAndRo;"
f,"int f = (rwAndRo << 6) | flags & ~mask;"
names,"ts:XmlBuiltinSubtypeNames[] names = [\"text\", \"element_ro\", \"pi_ro\", \"comment_ro\", \"element_rw\", \"pi_rw\", \"comment_rw\", \"element\", \"pi\", \"comment\"];"
result,"ts:XmlBuiltinSubtypeNames[] result = [];"
lat,"ListAtomicType lat = sc.tc.listAtomType(atom);"
rest,"Bdd rest = mappingSubtype(cellInnerVal(lat.rest));"
id,"AtomId id = (atom is RecAtom) ? [top, REC_ATOM, atom] : [top, TYPE_ATOM, atom.index];"
existing,"Memo? existing = memos[id];"
name,"string name = id[0][0].toUpperAscii() + (id[1] ? \"R\" : \"T\") + \".\" + id[2].toString();"
memo,"Memo memo = { id, name };"
sexpr,"ts:Atom sexpr;"
tc,"Context tc = sc.tc;"
argsLat,"var argsLat = <ListAtomicType>listAtomicType(tc, args);"
members,"ts:Type[] members = from var member in argsLat.members.initial select sexprFormSemTypeInternal(sc, cellInner(member));"
compressedCount,"int compressedCount = argsLat.members.fixedLength - argsLat.members.initial.length();"
repeatedMember,"ts:Type repeatedMember = members[members.length() - 1];"
members,"ts:Type[] members = from var member in lat.members.initial select sexprFormSemTypeInternal(sc, cellInner(member));"
restSemType,"SemType restSemType = cellInnerVal(lat.rest);"
rest,"ts:Type? rest = restSemType != NEVER ? sexprFormSemTypeInternal(sc, restSemType) : ();"
compressed,"boolean? compressed = lat.members.fixedLength == 0 ? () : lat.members.initial.length() != lat.members.fixedLength;"
mat,"MappingAtomicType mat = sc.tc.mappingAtomType(atom);"
fields,"ts:Field[] fields = [];"
restSemType,"SemType restSemType = cellInnerVal(mat.rest);"
rest,"ts:Type rest = sexprFormSemTypeInternal(sc, restSemType);"
bdd,"BddNode bdd = <BddNode>semType.subtypeDataList[0];"
listAtom,"ListAtomicType listAtom = <ListAtomicType>listAtomicType(cx, argList);"
fixedLengthArray,"var { members: fixedLengthArray, rest } = listAtom;"
paramTypes,"SemType[] paramTypes = from int i in 0 ..< fixedLengthArray.fixedLength select listAtomicTypeMemberAtInnerVal(listAtom, i);"
restType,"SemType? restType = cellInnerVal(rest) == NEVER ? () : rest;"
keyIndices,"int[] keyIndices;"
p,"SemType p = NEVER;"
t,"CellSemType[] t = memberTypes.slice(0, i);"
d,"SemType d = diff(cellInnerVal(memberTypes[i]), listMemberAtInnerVal(nt.members, nt.rest, indices[i]));"
t,"CellSemType[] t = memberTypes.clone();"
v,"[int, boolean][] v = from int i in indices select [i, intSubtypeContains(k, i)];"
max,"int max = range.max;"
min,"int min = int:max(0, range.min);"
indices1,"int[] indices1 = [];"
keyIndices,"int[] keyIndices = [];"
tc,"Context tc = typeContext(env);"
st1,"SemType st1 = fromSexpr(env, atoms, t1);"
st2,"SemType st2 = fromSexpr(env, atoms, t2);"
actual,"var actual = relationFromResult(isSubtype(tc, st1, st2), isSubtype(tc, st2, st1));"
expected,"string expected = relation.substring(6);"
s1,"string s1 = t1.toString();"
s2,"string s2 = t2.toString();"
endIndex,"int endIndex = lhsWrapped ? (lhs.endIndex + 2) : (lhs.endIndex + 1);"
op,"string op = regex[endIndex];"
nextIndex,"int nextIndex = skipTillEnd(regex, endIndex + 1);"
nextIndex,"int nextIndex = rhsWrapped ? (rhs.endIndex + 2) : (rhs.endIndex + 1);"
endIndex,"int endIndex = index;"
endIndex,"int endIndex = index + 1;"
openCount,"int openCount = 1;"
nextIndex,"int nextIndex = currentIndex;"
value,"string? value = ty.value;"
resolvedConst,"s:ResolvedConst resolvedConst = check resolveConstExpr(mod, defn, expr, expectedType);"
cx,"ExprContext cx = new ExprContext(mod, defn, constCode, (), ());"
operand,"bir:SingleValueConstOperand operand = <bir:SingleValueConstOperand>result;"
semType,"t:SemType semType = operand.semType;"
miTable,"table<ModuleIdImports> key(id) miTable = table [];"
id,"bir:ModuleId id = { org: decl.org ?: modId.org, names: decl.names };"
syms,"ModuleSymbols syms = { tc: t:typeContext(env) };"
files,"s:SourceFile[] files = from var p in scanned.parts select p.sourceFile();"
part,"s:ModulePart part = check s:parseModulePart(scannedPart);"
syms,"ModuleSymbols syms = { tc, allowAllTypes: true };"
parts,"s:ScannedModulePart[] parts = [];"
file,"s:SourceFile file = check loadSourcePart(sourceParts[i], i);"
directory,"string? directory = part?.directory;"
filename,"string? filename = part?.filename;"
lines,"string[]? lines = part?.lines;"
importsById,"ModuleIdImports[] importsById = scanned.importsById;"
moduleId,"var moduleId = importsById[i].id;"
resolved,"ModuleExports|string? resolved;"
partial,"boolean partial;"
msg,"d:Message msg = `unsupported module ${moduleIdToString(moduleId)}`;"
declPrefix,"string? declPrefix = decl.prefix;"
prefix,"string prefix = declPrefix == () ? moduleIdDefaultPrefix(moduleId) : declPrefix;"
defn,"s:ModuleLevelDefn? defn = mod[\"main\"];"
defn,"s:ModuleLevelDefn? defn = defns[\"init\"];"
returnType,"t:SemType returnType = (<bir:FunctionSignature>defn.signature).returnType;"
env,"t:Env env = new;"
syms,"ModuleSymbols syms = { tc: t:typeContext(env), allowAllTypes: true };"
loaded,"var loaded = check loadSourcePart(sourceParts[i], 0);"
part,"s:ScannedModulePart part = check s:scanModulePart(loaded, i);"
branch,"bir:BranchInsn branch = {dest, pos: stmt.startPos, backward};"
ec,"ExprContext ec = cx.exprContext(initialBindings);"
startRegister,"final int startRegister = cx.nextRegisterNumber();"
matched,"var { result: matched, block: testBlock, binding } = check codeGenExpr(ec, startBlock, (), stmt.expr);"
testBlock,"var { result: matched, block: testBlock, binding } = check codeGenExpr(ec, startBlock, (), stmt.expr);"
tc,"t:Context tc = cx.mod.tc;"
matchedType,"t:SemType matchedType = operandSemType(tc, matched);"
defaultClauseIndex,"int? defaultClauseIndex = ();"
hadWildcardPattern,"boolean hadWildcardPattern = false;"
equalMatchTests,"table<EqualMatchTest> key(value) equalMatchTests = table [];"
matchTests,"MatchTest[] matchTests = [];"
clauseLooksLike,"t:SemType[] clauseLooksLike = [];"
clauseUnmatchedLooksLike,"t:SemType[] clauseUnmatchedLooksLike = [];"
clausePatternUnions,"t:SemType[] clausePatternUnions = [];"
precedingPatternsUnion,"t:SemType precedingPatternsUnion = t:NEVER;"
clauseBlocks,"bir:BasicBlock[] clauseBlocks = [];"
clause,"var clause = stmt.clauses[i];"
clausePatternUnion,"t:SemType clausePatternUnion = t:NEVER;"
patternType,"t:SemType patternType;"
value,"t:SingleValue value = check resolveConstMatchPattern(cx, initialBindings, pattern, matchedType);"
operand,"bir:SingleValueConstOperand operand = { value, semType: patternType };"
mt,"EqualMatchTest mt = { value, operand, clauseIndex: i, pos: clause.opPos };"
mt,"BasicTypeMatchTest mt = { bitSet: t:ANY, clauseIndex: i, pos: clause.opPos };"
clauseBindings,"BindingChain?[] clauseBindings = [];"
unmatchedReg,"bir:Register unmatchedReg = <bir:Register>matched;"
pos,"var pos = stmt.clauses[i].opPos;"
ifTrueRegister,"bir:NarrowRegister ifTrueRegister = cx.createNarrowRegister(clauseLooksLike[i], binding.reg, pos);"
ifFalseRegister,"bir:NarrowRegister ifFalseRegister = cx.createNarrowRegister(clauseUnmatchedLooksLike[i], binding.reg, pos);"
nextBlock,"bir:BasicBlock nextBlock;"
typeBranch,"bir:TypeBranchInsn typeBranch = { ifTrue: clauseBlocks[i].label, ifFalse: nextBlock.label, ifTrueRegister, ifFalseRegister, operand: unmatchedReg, semType: clausePatternUnions[i], pos: pos };"
patternIndex,"int patternIndex = 0;"
clauseIndex,"int clauseIndex = mt.clauseIndex;"
testResult,"bir:TmpRegister testResult = cx.createTmpRegister(t:BOOLEAN, mt.pos);"
eq,"bir:EqualityInsn eq = { op: \"==\", pos: mt.pos, result: testResult, operands: [matched, mt.operand] };"
tt,"bir:TypeTestInsn tt = { pos: mt.pos, result: testResult, operand: <bir:Register>matched, semType: mt.bitSet, negated: false };"
nextBlock,"bir:BasicBlock nextBlock = cx.createBasicBlock(\"pattern.\" + patternIndex.toString());"
condBranch,"bir:CondBranchInsn condBranch = { operand: testResult, ifTrue: clauseBlocks[clauseIndex].label, ifFalse: nextBlock.label, pos: mt.pos } ;"
contBlock,"bir:BasicBlock? contBlock = ();"
bindings,"BindingChain? bindings = ();"
clause,"s:MatchClause clause = stmt.clauses[clauseIndex];"
stmtBlock,"bir:BasicBlock stmtBlock = clauseBlocks[clauseIndex];"
stmtBlockEnd,"var { block: stmtBlockEnd, bindings: blockBindings } = check codeGenScope(cx, stmtBlock, clauseBindings[clauseIndex] ?: initialBindings, clause.block);"
blockBindings,"var { block: stmtBlockEnd, bindings: blockBindings } = check codeGenScope(cx, stmtBlock, clauseBindings[clauseIndex] ?: initialBindings, clause.block);"
b,"bir:BasicBlock b = maybeCreateBasicBlock(ec, contBlock);"
branchToCont,"bir:BranchInsn branchToCont = { dest: b.label, pos: clause.startPos };"
branch,"bir:BranchInsn branch = { dest: clauseBlocks[defaultClauseIndex].label, pos: stmt.clauses[defaultClauseIndex].startPos };"
endPos,"Position endPos = stmt.clauses.length() > 0 ? (stmt.clauses[stmt.clauses.length() - 1].block.closeBracePos) : stmt.startPos;"
branch,"bir:BranchInsn branch = { dest: b.label, pos: endPos };"
condEffect,"CondExprEffect condEffect = check codeGenExprForCond(ec, startBlock, condition);"
errStmt,"s:Stmt? errStmt = scopeFirstStmt(notTaken);"
ifContBlock,"var { block: ifContBlock, bindings: ifBindings } = check codeGenScopeWithTypeMerger(cx, trueMerger, initialBindings, ifTrue);"
ifBindings,"var { block: ifContBlock, bindings: ifBindings } = check codeGenScopeWithTypeMerger(cx, trueMerger, initialBindings, ifTrue);"
contMerger,"TypeMerger contMerger = falseMerger;"
branch,"bir:BranchInsn branch = { dest: falseMerger.dest.label, pos: stmt.condition.startPos };"
elseContBlock,"var { block: elseContBlock, bindings: elseBindings } = check codeGenScopeWithTypeMerger(cx, falseMerger, initialBindings, ifFalse);"
elseBindings,"var { block: elseContBlock, bindings: elseBindings } = check codeGenScopeWithTypeMerger(cx, falseMerger, initialBindings, ifFalse);"
contBlock,"bir:BasicBlock contBlock = cx.createBasicBlock();"
joinPos,"Position joinPos = (ifFalse is s:StmtBlock ? ifFalse : ifFalse.ifTrue).closeBracePos;"
branch,"bir:BranchInsn branch = { dest: contBlock.label, pos: joinPos };"
combinedOrigin,"TypeMergerOrigin? combinedOrigin = { bindings: ifBindings, label: ifContBlock.label, prev: { bindings: elseBindings, label: elseContBlock.label, prev: () } };"
bindings,"BindingChain? bindings = codeGenTypeMerge(ec, contBlock, initialBindings, combinedOrigin, ifTrue.endPos);"
contBlock,"bir:BasicBlock? contBlock = ifContBlock ?: elseContBlock;"
bindings,"BindingChain? bindings = ifBindings ?: elseBindings;"
operand,"bir:Operand operand;"
insn,"bir:RetInsn insn = { operand, pos: stmt.kwPos };"
operand,"var { result: operand, block: nextBlock } = check cx.codeGenExpr(startBlock, initialBindings, t:ERROR, panicExpr);"
nextBlock,"var { result: operand, block: nextBlock } = check cx.codeGenExpr(startBlock, initialBindings, t:ERROR, panicExpr);"
insn,"bir:PanicInsn insn = { operand, pos: stmt.kwPos };"
semType,"t:SemType semType = check cx.resolveTypeDesc(td);"
result,"bir:VarRegister|bir:FinalRegister result = isFinal ? cx.createFinalRegister(semType, namePos, name) : cx.createVarRegister(semType, namePos, name);"
nextBlock,"bir:BasicBlock nextBlock = check codeGenAssign(cx, initialBindings, startBlock, result, initExpr, semType, stmt.opPos);"
nextBlock,"bir:BasicBlock nextBlock = check codeGenAssign(cx, initialBindings, startBlock, cx.createVarRegister(semType, pos, \"_\"), expr, semType, pos);"
nextBlock,"bir:BasicBlock nextBlock = check codeGenAssign(cx, initialBindings, startBlock, cx.createVarRegister(t:ANY, stmt.opPos, \"_\"), expr, t:ANY, stmt.opPos);"
nextBlock,"bir:BasicBlock nextBlock = check codeGenAssign(cx, initialBindings, startBlock, unnarrowedReg, expr, unnarrowedReg.semType, pos);"
binding,"Binding binding = check lookupVarRefBinding(cx, varName, initialBindings, pos);"
unnarrowed,"DeclBinding unnarrowed = unnarrowBinding(binding);"
unnarrowedReg,"bir:VarRegister unnarrowedReg = <bir:VarRegister>unnarrowed.reg;"
bindings,"BindingChain? bindings;"
operand,"var { result: operand, block: nextBlock } = check cx.codeGenExpr(block, initialBindings, semType, expr);"
nextBlock,"var { result: operand, block: nextBlock } = check cx.codeGenExpr(block, initialBindings, semType, expr);"
insn,"bir:AssignInsn insn = { pos, result, operand };"
reg,"bir:Register reg;"
block,"bir:BasicBlock block;"
containerOperand,"bir:Operand containerOperand;"
result,"bir:Operand result;"
reg,"var { result: reg, block: block1 } = check codeGenLExpr(cx, startBlock, initialBindings, lValue.container);"
block1,"var { result: reg, block: block1 } = check codeGenLExpr(cx, startBlock, initialBindings, lValue.container);"
indexType,"t:BasicTypeBitSet indexType;"
index,"var { result: index, block: nextBlock } = check cx.codeGenExprForInt(block1, initialBindings, lValue.index);"
nextBlock,"var { result: index, block: nextBlock } = check cx.codeGenExprForInt(block1, initialBindings, lValue.index);"
memberType,"t:SemType memberType = t:listMemberTypeInnerVal(cx.mod.tc, reg.semType, index.semType);"
insn,"bir:ListSetInsn insn = { operands: [reg, index, operand], pos: lValue.opPos };"
index,"var { result: index, block: nextBlock } = check codeGenLExprMappingKey(cx, block1, initialBindings, lValue, reg.semType);"
nextBlock,"var { result: index, block: nextBlock } = check codeGenLExprMappingKey(cx, block1, initialBindings, lValue, reg.semType);"
memberType,"t:SemType memberType = t:mappingMemberTypeInnerVal(cx.mod.tc, reg.semType, index.semType);"
insn,"bir:MappingSetInsn insn = { operands: [ reg, index, operand], pos: lValue.opPos };"
fieldName,"string fieldName = mappingLValue.fieldName;"
pos,"var { lValue, expr, op, opPos: pos } = stmt;"
container,"var { result: container, block: nextBlock } = check cx.codeGenExpr(startBlock, initialBindings, (), lValue.container);"
nextBlock,"var { result: container, block: nextBlock } = check cx.codeGenExpr(startBlock, initialBindings, (), lValue.container);"
nextBlock,"var { block: nextBlock, result: operand } = check codeGenCompoundableBinaryExpr(cx.exprContext(initialBindings), startBlock, op, pos, result, rexpr);"
operand,"var { block: nextBlock, result: operand } = check codeGenCompoundableBinaryExpr(cx.exprContext(initialBindings), startBlock, op, pos, result, rexpr);"
index,"var { result: index, block: nextBlock } = check cx.codeGenExprForInt(bb, initialBindings, lValue.index);"
nextBlock,"var { result: index, block: nextBlock } = check cx.codeGenExprForInt(bb, initialBindings, lValue.index);"
memberType,"t:SemType memberType = t:listMemberTypeInnerVal(cx.mod.tc, list.semType, index.semType);"
member,"bir:TmpRegister member = cx.createTmpRegister(memberType, lValue.opPos);"
getInsn,"bir:ListGetInsn getInsn = { result: member, operands: [list, index], pos: lValue.opPos };"
setInsn,"bir:ListSetInsn setInsn = { operands: [list, index, result], pos: lValue.opPos };"
k,"var { result: k, block: block1 } = check codeGenLExprMappingKey(cx, bb, initialBindings, lValue, mapping.semType);"
block1,"var { result: k, block: block1 } = check codeGenLExprMappingKey(cx, bb, initialBindings, lValue, mapping.semType);"
member,"var { result: member, block: block2 } = check codeGenMappingGet(ec, block1, mapping, \"[\", k, pos);"
block2,"var { result: member, block: block2 } = check codeGenMappingGet(ec, block1, mapping, \"[\", k, pos);"
setInsn,"bir:MappingSetInsn setInsn = { operands: [ mapping, k, result], pos: lValue.opPos };"
operand,"var { result: operand, block: nextBlock } = check codeGenExpr(ec, bb, member.semType, rexpr);"
nextBlock,"var { result: operand, block: nextBlock } = check codeGenExpr(ec, bb, member.semType, rexpr);"
operand,"var { result: operand, block: nextBlock } = check codeGenExprForInt(ec, bb, rexpr);"
nextBlock,"var { result: operand, block: nextBlock } = check codeGenExprForInt(ec, bb, rexpr);"
expr,"s:CallExpr expr = stmt.callExpr;"
o,"var { result: o, block: nextBlock, binding } = check cx.codeGenExpr(bb, initialBindings, t:ERROR, expr);"
nextBlock,"var { result: o, block: nextBlock, binding } = check cx.codeGenExpr(bb, initialBindings, t:ERROR, expr);"
semType,"t:SemType semType = operandSemType(cx.mod.tc, o);"
errorType,"t:SemType errorType = t:intersect(semType, t:ERROR);"
resultType,"t:SemType resultType;"
operand,"bir:Register operand = <bir:Register>o;"
errorBlock,"bir:BasicBlock errorBlock = cx.createBasicBlock();"
okBlock,"bir:BasicBlock okBlock = cx.createBasicBlock();"
reg,"bir:Register reg = <bir:Register>operand;"
errorReg,"bir:NarrowRegister errorReg = cx.createNarrowRegister(errorType, reg);"
result,"bir:NarrowRegister result = cx.createNarrowRegister(okType, reg);"
insn,"bir:TypeBranchInsn insn = { operand: operand, semType: t:ERROR, ifTrue: errorBlock.label, ifFalse: okBlock.label, pos, ifTrueRegister: errorReg, ifFalseRegister: result };"
b,"var b = check lookupLocalVarRef(cx, cx.mod, name, bindings, pos);"
binding,"Binding? binding = envLookup(name, bindings);"
defn,"s:ModuleLevelDefn? defn = mod.defns[name];"
signature,"var signature = defn.signature;"
isPublic,"boolean isPublic = defn.vis == \"public\";"
symbol,"bir:InternalSymbol symbol = { identifier: name, isPublic };"
binding,"Binding? binding = bindingsLookup(name, bindings);"
tem,"BindingChain? tem = bindings;"
result,"bir:AssignTmpRegister result = cx.createAssignTmpRegister(t:BOOLEAN, pos);"
assignInsn,"bir:AssignInsn assignInsn = { operand: singletonOperand(cx, value), pos, result };"
brInsn,"bir:BranchInsn brInsn = { dest: contBlock, pos };"
operand,"bir:BooleanOperand operand;"
nextBlock,"var { result , block: nextBlock, binding } = check codeGenExpr(cx, bb, (), left);"
l,"var { result: l, block: block1, binding: lBinding } = check codeGenExpr(cx, bb, (), left);"
block1,"var { result: l, block: block1, binding: lBinding } = check codeGenExpr(cx, bb, (), left);"
lBinding,"var { result: l, block: block1, binding: lBinding } = check codeGenExpr(cx, bb, (), left);"
r,"var { result: r, block: nextBlock, binding: rBinding } = check codeGenExpr(cx, block1, (), right);"
nextBlock,"var { result: r, block: nextBlock, binding: rBinding } = check codeGenExpr(cx, block1, (), right);"
rBinding,"var { result: r, block: nextBlock, binding: rBinding } = check codeGenExpr(cx, block1, (), right);"
exact,"boolean exact = op.length() == 3;"
narrowingCompare,"[Binding, t:SingleValue]? narrowingCompare = ();"
lShape,"t:WrappedSingleValue? lShape = operandSingleShape(l);"
rShape,"t:WrappedSingleValue? rShape = operandSingleShape(r);"
negated,"boolean negated = op.startsWith(\"!\");"
ty,"t:SemType ty = t:singleton(tc, value);"
result,"CondExprEffect result = check codeGenTypeTestForCond(cx, nextBlock, ty, binding, negated, pos, prevs);"
taken,"TypeMerger? taken = negated ? result.falseMerger : result.trueMerger;"
result,"bir:Register result;"
reg,"bir:TmpRegister reg = cx.createTmpRegister(t:BOOLEAN);"
insn,"bir:EqualityInsn insn;"
trueMerger,"TypeMerger trueMerger = createMerger(cx, block.label, prevs?.trueMerger);"
falseMerger,"TypeMerger falseMerger = createMerger(cx, block.label, prevs?.falseMerger);"
condBranch,"bir:CondBranchInsn condBranch = { operand: result, ifTrue: trueMerger.dest.label, ifFalse: falseMerger.dest.label, pos: expr.startPos };"
block,"bir:BasicBlock block = cx.createBasicBlock();"
nonNilResult,"bir:Operand nonNilResult = nonNilEffect.result;"
nonNilBlock,"bir:BasicBlock nonNilBlock = nonNilEffect.block;"
result,"bir:AssignTmpRegister result = cx.createAssignTmpRegister(t:union(operandSemType(cx.mod.tc, nonNilResult), t:NIL), pos);"
nilAssign,"bir:AssignInsn nilAssign = { result, operand: bir:NIL_OPERAND, pos };"
branchInsn,"bir:BranchInsn branchInsn = { dest: block.label, pos };"
valAssign,"bir:AssignInsn valAssign = { result, operand: nonNilResult, pos };"
ifNilBlock,"bir:BasicBlock? ifNilBlock = ();"
currentBlock,"bir:BasicBlock currentBlock = bb;"
newOperands,"bir:Operand[] newOperands = [];"
operand,"var { result: operand, block } = check codeGenExpr(cx, currentBlock, expected, operandExpr);"
nextBlock,"bir:BasicBlock nextBlock = currentBlock;"
operand,"bir:Operand operand = newOperands[i];"
baseType,"t:SemType baseType = t:diff(operand.semType, t:NIL);"
ifTrueRegister,"bir:NarrowRegister ifTrueRegister = cx.createNarrowRegister(t:NIL, operand);"
ifFalseRegister,"bir:NarrowRegister ifFalseRegister = cx.createNarrowRegister(baseType, operand);"
ifTrueBlock,"bir:BasicBlock ifTrueBlock = maybeCreateBasicBlock(cx, ifNilBlock);"
branchInsn,"bir:TypeBranchInsn branchInsn = { operand, semType: t:NIL, ifTrue: ifTrueBlock.label, ifFalse: nextBlock.label, ifTrueRegister, ifFalseRegister, pos };"
memberType,"t:SemType memberType = t:mappingMemberTypeInner(cx.mod.tc, mapping.semType, k.semType);"
maybeMissing,"boolean maybeMissing = true;"
fieldName,"string fieldName = (<bir:StringConstOperand>k).value;"
name,"bir:INSN_MAPPING_FILLING_GET|bir:INSN_MAPPING_GET name = bir:INSN_MAPPING_GET;"
result,"bir:TmpRegister result = cx.createTmpRegister(memberType, pos);"
insn,"bir:Insn insn = { name, result, operands: [mapping, k], pos };"
r,"var { result: r, block: nextBlock } = check codeGenExprForInt(cx, block1, index);"
nextBlock,"var { result: r, block: nextBlock } = check codeGenExprForInt(cx, block1, index);"
memberType,"t:SemType memberType = t:listMemberTypeInnerVal(cx.mod.tc, l.semType, r.semType);"
insn,"bir:ListGetInsn insn = { result, operands: [l, r], pos, fill };"
r,"var { result: r, block: nextBlock } = check codeGenExprForString(cx, block1, index);"
nextBlock,"var { result: r, block: nextBlock } = check codeGenExprForString(cx, block1, index);"
resultType,"t:SemType resultType = (flags & VALUE_SINGLE_SHAPE) != 0 ? t:singleton(cx.mod.tc, value) : t:INT;"
result,"bir:TmpRegister result = cx.createTmpRegister(t:INT, pos);"
insn,"bir:IntBitwiseBinaryInsn insn = { op: \"^\", pos, operands: [singletonIntOperand(cx.mod.tc, -1), operand], result };"
arith,"ArithmeticOperand? arith = arithmeticOperand(operand);"
result,"bir:TmpRegister result;"
insn,"bir:Insn insn;"
intOperand,"bir:IntOperand intOperand = arith[1];"
floatOperand,"bir:FloatOperand floatOperand = arith[1];"
resultType,"t:SemType resultType = t:FLOAT;"
decimalOperand,"bir:DecimalOperand decimalOperand = arith[1];"
resultType,"t:SemType resultType = t:DECIMAL;"
pair,"ArithmeticOperandPair? pair = arithmeticOperandPair(lhs, rhs);"
operands,"readonly & bir:IntOperand[2] operands = pair[1];"
resultFlags,"ValueFlags resultFlags = leftFlags & rightFlags;"
value,"int value = check intArithmeticEval(cx, pos, op, leftVal, rightVal);"
resultType,"t:SemType resultType = (resultFlags & VALUE_SINGLE_SHAPE) != 0 ? t:singleton(cx.mod.tc, value) : t:INT;"
operands,"readonly & bir:FloatOperand[2] operands = pair[1];"
value,"float value = floatArithmeticEval(op, leftVal, rightVal);"
insn,"bir:FloatArithmeticBinaryInsn insn = { op, pos, operands, result };"
operands,"readonly & bir:DecimalOperand[2] operands = pair[1];"
value,"decimal value = check decimalArithmeticEval(cx, pos, op, leftVal, rightVal);"
insn,"bir:DecimalArithmeticBinaryInsn insn = { op, pos, operands, result };"
operands,"readonly & bir:StringOperand[2] operands = pair[1];"
insn,"bir:StringConcatInsn insn = { operands: pair[1], result, pos };"
operandConstraints,"t:IntSubtypeConstraints?[] operandConstraints = from bir:Operand operand in operands select t:intSubtypeConstraints(operand.semType);"
constraints,"t:IntSubtypeConstraints[] constraints = [];"
noPanicMin,"int noPanicMin;"
noPanicMax,"int noPanicMax;"
operand,"var { result: operand, block: nextBlock } = check codeGenExprForBoolean(cx, bb, expr);"
nextBlock,"var { result: operand, block: nextBlock } = check codeGenExprForBoolean(cx, bb, expr);"
result,"bir:TmpRegister result = cx.createTmpRegister(t:BOOLEAN, pos);"
insn,"bir:BooleanNotInsn insn = { operand: <bir:Register>operand, result, pos };"
flipped,"PrevTypeMergers? flipped = prevs == () ? () : { trueMerger: prevs.falseMerger, falseMerger: prevs.trueMerger };"
isOr,"boolean isOr = op == \"||\";"
lhsEffect,"var lhsEffect = check codeGenExprForCond(cx, bb, left, prevs);"
lhsTrueMerger,"var { trueMerger: lhsTrueMerger, falseMerger: lhsFalseMerger } = lhsEffect;"
lhsFalseMerger,"var { trueMerger: lhsTrueMerger, falseMerger: lhsFalseMerger } = lhsEffect;"
dummyBlock,"bir:BasicBlock dummyBlock = cx.createDummyBasicBlock(merger.dest);"
rhsBlock,"var { block: rhsBlock, bindings: rhsBindings } = codeGenTypeMergeFromMerger(cx, rhsMerger, pos);"
rhsBindings,"var { block: rhsBlock, bindings: rhsBindings } = codeGenTypeMergeFromMerger(cx, rhsMerger, pos);"
leftWidenedType,"t:SemType leftWidenedType = t:widenUnsigned(lhs.semType);"
rightWidenedType,"t:SemType rightWidenedType = t:widenUnsigned(rhs.semType);"
value,"int value = bitwiseEval(op, leftValue, rightValue);"
result,"bir:TmpRegister result = cx.createTmpRegister(resultType, pos);"
insn,"bir:IntBitwiseBinaryInsn insn = { op, pos, operands: [lhs, rhs], result };"
nextBlock,"bir:BasicBlock nextBlock = bb;"
atomicType,"t:ListAtomicType atomicType;"
requiredType,"t:SemType requiredType = t:listAtomicTypeMemberAtInnerVal(atomicType, i);"
memberSemTypes,"t:SemType[] memberSemTypes = [];"
broadType,"t:SemType broadType = t:singleShape(operand.semType) == () ? operand.semType : t:widenToBasicTypes(operand.semType);"
result,"bir:TmpRegister result = cx.createTmpRegister(resultType, expr.opPos);"
insn,"bir:ListConstructInsn insn = { operands: operands.cloneReadOnly(), result, pos: expr.opPos };"
insn,"bir:ListConstructInsn|bir:MappingConstructInsn insn;"
result,"bir:TmpRegister result = cx.createTmpRegister(filler.semType);"
memberFiller,"t:Filler? memberFiller = t:filler(cx.mod.tc, t:listAtomicTypeMemberAtInner(atomicType, index));"
expectedListType,"t:SemType expectedListType = t:intersect(expectedType, t:LIST);"
lat,"t:ListAtomicType? lat = t:listAtomicType(tc, expectedListType);"
len,"int len = expr.members.length();"
alts,"t:ListAlternative[] alts = from var alt in t:listAlternatives(tc, expectedListType) where listAlternativeAllowsLength(alt, len) select alt;"
semType,"t:SemType semType = alts[0].semType;"
pos,"t:ListAtomicType? pos = alt.pos;"
minLength,"int minLength = pos.members.fixedLength;"
fieldPos,"map<Position> fieldPos = {};"
mat,"t:MappingAtomicType mat;"
name,"string name = f.name;"
prevPos,"Position? prevPos = fieldPos[name];"
insn,"bir:MappingConstructInsn insn = { fieldNames: fieldNames.cloneReadOnly(), operands: operands.cloneReadOnly(), result, pos: expr.opPos };"
expectedMappingType,"t:SemType expectedMappingType = t:intersect(expectedType, t:MAPPING);"
mat,"t:MappingAtomicType? mat = t:mappingAtomicType(tc, expectedMappingType);"
fieldNames,"string[] fieldNames = from var f in expr.fields order by f.name select f.name;"
alts,"t:MappingAlternative[] alts = from var alt in t:mappingAlternatives(tc, expectedMappingType) where mappingAlternativeAllowsFields(alt, fieldNames) select alt;"
pos,"t:MappingAtomicType? pos = alt.pos;"
len,"int len = fieldNames.length();"
operand,"var { result: operand, block } = check codeGenExprForString(cx, bb, message);"
result,"bir:TmpRegister result = cx.createTmpRegister(t:ERROR, pos);"
insn,"bir:ErrorConstructInsn insn = { result, operand, pos };"
l,"var { result: l, block: block1 } = check codeGenExpr(cx, bb, (), left);"
block1,"var { result: l, block: block1 } = check codeGenExpr(cx, bb, (), left);"
r,"var { result: r, block: nextBlock } = check codeGenExpr(cx, block1, (), right);"
nextBlock,"var { result: r, block: nextBlock } = check codeGenExpr(cx, block1, (), right);"
lType,"t:SemType lType = operandSemType(tc, l);"
rType,"t:SemType rType = operandSemType(tc, r);"
insn,"bir:CompareInsn insn = { op, pos, operands: [l, r], result };"
ad,"t:SemType ad = t:createAnydata(tc);"
value,"boolean value = negated == (leftValue != rightValue);"
value,"boolean value = negated == (leftValue !== rightValue);"
insn,"bir:EqualityInsn insn = { op, pos, operands: [l, r], result };"
binding,"Binding? binding;"
prefix,"string? prefix = ref.prefix;"
v,"var v = check lookupImportedVarRef(cx, prefix, ref.name, ref.qNamePos);"
v,"var v = check cx.lookupLocalVarRef(ref.name, ref.startPos);"
toType,"t:SemType toType = check cx.resolveTypeDesc(tcExpr.td);"
operandExpectedType,"t:SemType operandExpectedType = expected == () ? toType : t:intersect(toType, expected);"
operand,"var { result: operand, block: nextBlock } = check codeGenExpr(cx, bb, operandExpectedType, tcExpr.operand);"
nextBlock,"var { result: operand, block: nextBlock } = check codeGenExpr(cx, bb, operandExpectedType, tcExpr.operand);"
fromType,"t:SemType fromType = operandSemType(cx.mod.tc, operand);"
toNumType,"t:BasicTypeBitSet? toNumType = t:singleNumericType(toType);"
resultType,"t:SemType resultType = t:intersect(fromType, toType);"
result,"bir:TmpRegister result = cx.createTmpRegister(resultType, tcExpr.opPos);"
insn,"bir:TypeCastInsn insn = { operand: reg, semType: toType, pos: tcExpr.opPos, result };"
resultType,"t:SemType resultType = t:union(t:diff(fromType, t:NUMBER), toNumType);"
converted,"int|float|decimal? converted = ();"
insn,"bir:ConvertToIntInsn insn = { operand, result, pos };"
insn,"bir:ConvertToFloatInsn insn = { operand, result, pos };"
insn,"bir:ConvertToDecimalInsn insn = { operand, result, pos };"
reg,"bir:Register reg = opBinding.reg;"
curSemType,"t:SemType curSemType = reg.semType;"
diff,"t:SemType diff = t:diff(curSemType, semType);"
intersect,"t:SemType intersect;"
ifTrueRegister,"bir:NarrowRegister ifTrueRegister = cx.createNarrowRegister(intersect, reg);"
ifFalseRegister,"bir:NarrowRegister ifFalseRegister = cx.createNarrowRegister(diff, reg);"
trueMerger,"TypeMerger trueMerger = createNarrowMerger(cx, opBinding, ifTrueRegister, pos, nextBlock.label, prevs?.trueMerger);"
falseMerger,"TypeMerger falseMerger = createNarrowMerger(cx, opBinding, ifFalseRegister, pos, nextBlock.label, prevs?.falseMerger);"
insn,"bir:TypeBranchInsn insn = { operand: reg, semType: intersect, ifTrue: trueMerger.dest.label, ifFalse: falseMerger.dest.label, ifTrueRegister, ifFalseRegister, pos };"
branch,"bir:BranchInsn branch = { dest: merger.dest.label, pos };"
newMerger,"TypeMerger newMerger = createMerger(cx, block.label, ());"
branch,"bir:BranchInsn branch = { dest: newMerger.dest.label, pos };"
nextBlock,"var { result, block: nextBlock } = check codeGenExpr(cx, bb, expected, left);"
curSemType,"t:SemType curSemType = operandSemType(tc, operand);"
insn,"bir:TypeTestInsn insn = { operand: reg, semType, result, negated, pos };"
o,"var { result: o, block: nextBlock, binding } = check codeGenExpr(cx, bb, expected, expr);"
nextBlock,"var { result: o, block: nextBlock, binding } = check codeGenExpr(cx, bb, expected, expr);"
resultType,"t:SemType resultType = t:diff(semType, t:ERROR);"
insn,"bir:RetInsn insn = { operand, pos };"
insn,"bir:PanicInsn insn = { operand, pos };"
prefix,"string? prefix = expr.prefix;"
func,"bir:FunctionRef func;"
funcRegister,"bir:Register? funcRegister = ();"
ref,"var ref = cx.lookupLocalVarRef(expr.funcName, expr.qNamePos);"
curBlock,"bir:BasicBlock curBlock = bb;"
args,"bir:Operand[] args = [];"
restParamType,"t:SemType? restParamType = func.signature.restParamType;"
regularArgCount,"int regularArgCount = restParamType == () ? expr.args.length() : func.signature.paramTypes.length() - 1;"
arg,"var { result: arg, block: nextBlock } = check codeGenArgument(cx, curBlock, expr, func, i);"
nextBlock,"var { result: arg, block: nextBlock } = check codeGenArgument(cx, curBlock, expr, func, i);"
restArgs,"s:Expr[] restArgs = from int i in regularArgCount ..< expr.args.length() select expr.args[i];"
endPos,"Position endPos;"
restArgCount,"int restArgCount = restArgs.length();"
varArgList,"s:ListConstructorExpr varArgList = { startPos, endPos, opPos: startPos, members: restArgs};"
restListTy,"t:SemType restListTy = func.signature.paramTypes[func.signature.paramTypes.length() - 1];"
arg,"var { result: arg, block: nextBlock } = check codeGenListConstructor(cx, curBlock, restListTy, varArgList);"
nextBlock,"var { result: arg, block: nextBlock } = check codeGenListConstructor(cx, curBlock, restListTy, varArgList);"
target,"var { result: target, block: curBlock } = check codeGenExpr(cx, bb, (), expr.target);"
curBlock,"var { result: target, block: curBlock } = check codeGenExpr(cx, bb, (), expr.target);"
func,"bir:FunctionRef func = check getLangLibFunctionRef(cx, target, expr.methodName, expr.namePos);"
args,"bir:Operand[] args = [target];"
signature,"bir:FunctionSignature signature = functionSignature(tc, <t:ComplexSemType>register.semType);"
symbol,"bir:InternalSymbol symbol = { isPublic: false, identifier: registerName(register) };"
reg,"bir:TmpRegister reg = cx.createTmpRegister(returnType, pos);"
call,"bir:CallInsn call = { func, result: reg, args: args.cloneReadOnly(), pos };"
operands,"[bir:Register, bir:Operand...] operands = [func, ...args];"
call,"bir:CallIndirectInsn call = { result: reg, operands: operands.cloneReadOnly(), pos };"
nSuppliedArgs,"int nSuppliedArgs = call is s:FunctionCallExpr ? call.args.length() : call.args.length() + 1;"
nExpectedArgs,"int nExpectedArgs = func.signature.paramTypes.length() - (func.signature.restParamType != () ? 1 : 0);"
trueBindings,"BindingChain? trueBindings = codeGenTypeMerge(cx, merger.dest, cx.bindings, merger.origins, pos);"
narrowed,"BindingChain? narrowed = bindingLimit;"
unnarrowed,"Binding unnarrowed = originGroup.unnarrowed;"
existing,"Binding existing = <Binding>envLookup(unnarrowed.name, bindingLimit);"
merged,"bir:NarrowRegister merged = cx.createNarrowRegister(originGroup.union, unnarrowed.reg, pos);"
insn,"bir:TypeMergeInsn insn = { result: merged, pos, operands: originGroup.narrowedRegs.cloneReadOnly(), predecessors: originGroup.origins.cloneReadOnly() };"
numOrigins,"int numOrigins = 0;"
origin,"TypeMergerOrigin? origin = origins;"
originGroups,"final OriginGroupTable originGroups = table [];"
bindings,"BindingChain? bindings = origin.bindings;"
added,"boolean[] added = [];"
reg,"bir:Register reg = head.reg;"
unnarrowed,"var unnarrowed = head.unnarrowed;"
number,"int number = unnarrowed.reg.number;"
originGroup,"MergeOriginGroup? originGroup = originGroups[number];"
semType,"t:SemType semType = reg.semType;"
defn,"var defn = lookupImportedVarRef(cx, prefix, identifier, pos);"
mod,"Import mod = check lookupPrefix(cx.mod, cx.defn, prefix, pos);"
moduleName,"LangLibModuleName? moduleName = operandLangLibModuleName(target);"
erasedSignature,"bir:FunctionSignature? erasedSignature = getLangLibFunction(moduleName, methodName);"
symbol,"bir:ExternalSymbol symbol = { module: { org: \"ballerina\", names: [\"lang\", moduleName] }, identifier: methodName };"
signature,"bir:FunctionSignature signature = erasedSignature;"
counter,"Counter counter = {};"
inst,"bir:FunctionSignature inst = instantiateSignature(sig, memberType, arrayType, counter);"
atomic,"t:ListAtomicType? atomic = t:listAtomicType(tc, listType);"
memberType,"t:SemType memberType = t:listMemberTypeInnerVal(tc, listType, t:INT);"
def,"t:ListDefinition def = new;"
restParamType,"bir:SemType? restParamType = sig.restParamType;"
paramTypes,"bir:SemType[] paramTypes = from var ty in sig.paramTypes select instantiateType(ty, memberType, containerType, counter);"
l,"ArithmeticOperand? l = arithmeticOperand(lhs);"
r,"ArithmeticOperand? r = arithmeticOperand(rhs);"
btc,"t:BasicTypeCode? btc = t:basicTypeCode(t:widenToBasicTypes(operand.semType));"
btc,"t:BasicTypeCode? btc = t:basicTypeCode(t:widenToBasicTypes(semType));"
env,"t:Env env = tc.env;"
defn,"t:FunctionDefinition defn = new(env);"
rest,"t:SemType rest = restParamType is () ? t:NEVER : restParamType;"
ty,"t:SemType ty = reg.semType;"
wrapped,"t:WrappedSingleValue? wrapped = t:singleShape(ty);"
shape,"t:SingleValue shape = wrapped.value;"
value,"var value = operand.value;"
flags,"ValueFlags flags = VALUE_CONST;"
wrapped,"t:WrappedSingleValue? wrapped = t:singleShape(operand.semType);"
value,"float value = operand.value;"
shape,"float? shape = t:singleFloatShape(operand.semType);"
value,"decimal value = operand.value;"
shape,"decimal? shape = t:singleDecimalShape(operand.semType);"
value,"int value = operand.value;"
shape,"int? shape = t:singleIntShape(operand.semType);"
value,"boolean value = operand.value;"
shape,"boolean? shape = t:singleBooleanShape(operand.semType);"
value,"string value = operand.value;"
shape,"string? shape = t:singleStringShape(operand.semType);"
constCond,"boolean constCond;"
merger,"TypeMerger merger;"
origins,"TypeMergerOrigin origins = { bindings, label: originLabel, prev: merger?.origins };"
defn,"ExportedDefn? defn = mod.defns[identifier];"
exports,"map<ExportedDefn> exports = {};"
export,"ExportedDefn|false? export;"
names,"string[] names = id.names;"
m,"string m = \".\".'join(...id.names);"
implicitImport,"Import? implicitImport = autoImportPrefixes[prefix];"
imported,"Import? imported = mod.partPrefixes[modDefn.part.partIndex][prefix];"
defn,"ExportedDefn? defn = (check lookupPrefix(mod, modDefn, prefix, td.startPos)).defns[td.typeName];"
qName,"string qName = prefix + \":\" + td.typeName;"
loc,"d:Location loc = s:qNameLocationInDefn(modDefn, td.qNamePos);"
ty,"t:SemType ty = check resolveTypeDesc(mod, modDefn, depth, td.td);"
defn,"t:FunctionDefinition? defn = td.defn;"
a,"s:TypeDesc[] a = [];"
rest,"t:SemType rest = t:NEVER;"
args,"t:SemType[] args = from var x in a select check resolveTypeDesc(mod, modDefn, depth + 1, x);"
retTy,"s:TypeDesc? retTy = td.ret;"
ret,"t:SemType ret = retTy != () ? check resolveTypeDesc(mod, modDefn, depth + 1, retTy) : t:NIL;"
td2,"s:TypeDesc td2 = td;"
ty,"t:SemType ty = check resolveTypeDesc(mod, modDefn, depth, td2.td);"
t,"t:SemType t = check resolveTypeDesc(mod, modDefn, depth, td.constituent);"
loc,"d:Location loc = d:location(modDefn.part.file, td.pos);"
t,"t:SemType t = check resolveTypeDesc(mod, modDefn, depth, td.row);"
loc,"d:Location loc = d:location(modDefn.part.file, { startPos: td.startPos, endPos: td.endPos });"
ty,"t:SemType ty = types.get(\"TyName\");"
tc,"var tc = t:typeContext(env);"
atoms,"map<ts:Atom> atoms = {};"
tySexpr,"ts:Type tySexpr = t:toSexpr(tc, ty, atoms);"
atomName,"string? atomName = t:atomRefSexpr(tySexpr);"
actual,"sexpr:Data actual = atomName != () ? atoms.get(atomName) : tySexpr;"
roundtripTy,"t:SemType roundtripTy = t:fromSexpr(env, t:atomTableFromSexpr(env, atoms), tySexpr);"
lines,"string[] lines = check io:fileReadLines(README_PATH);"
result,"map<[string, string, string?]> result = {};"
lineNo,"int lineNo = 0;"
line,"string line = unescapeMdTable(escapedLine);"
t,"int[] t = tickPos(line);"
ticks,"int[] ticks = [];"
startPos,"int startPos = 0;"
tickPos,"int? tickPos = l.indexOf(\"`\", startPos) + 1;"
chars,"int[] chars = from int c in row.toCodePointInts() where c != 0x5c select c;"
paddingContent,"string[] paddingContent = [];"
padding,"string padding = \"\".'join(...paddingContent);"
carets,"string carets = lib:stringRepeat(\"^\", contentLength);"
tc,"t:Context tc = t:typeContext(env);"
t1,"t:SemType t1 = check j:parse(tc, j1);"
t2,"t:SemType t2 = check j:parse(tc, j2);"
tem,"int tem = t:bddGetCount();"
b,"boolean b = t:isSubtype(tc, t1, t2);"
outBasename,"string outBasename = check chooseBaltCaseOutputFilename(filename, t, i);"
lines,"string[] lines = t.content;"
emitter,"LlvmEmitter emitter = new(check file:joinPath(outDir, outBasename), nbackOptions, options);"
err,"CompileError? err = compileBalFile({ lines }, basename, emitter);"
expectOutDir,"string? expectOutDir = options.expectOutDir;"
expectFilename,"string expectFilename = check file:joinPath(expectOutDir ?: outDir, outBasename) + \".txt\";"
tests,"BaltTestCase[] tests = [];"
maybeHeader,"BaltTestHeader? maybeHeader = ();"
prevFiledBody,"string? prevFiledBody = ();"
prevFiledName,"string? prevFiledName = ();"
s,"State s = BOF;"
header,"BaltTestHeader header = <BaltTestHeader>maybeHeader;"
expect,"string[] expect = [];"
comment,"int? comment = l.indexOf(\""
begin,"int begin = <int> comment + 2;"
output,"int? output = l.indexOf(OUTPUT_MARKER, begin);"
err,"int? err = l.indexOf(ERROR_MARKER, begin);"
pnk,"int? pnk = l.indexOf(PANIC_MARKER, begin);"
msg,"string msg = l.substring(pnk + PANIC_MARKER.length() + 1);"
basename,"string basename = check file:basename(filename);"
len,"int len = s.length() ;"
id,"bir:ModuleId id = birMod.getId();"
outputBasename,"string? outputBasename = self.outputBasename;"
initMod,"LlvmModule initMod = check nback:buildInitModule(env, self.programModules.reverse(), potentialEntryFuncs);"
bir,"string bir = check tback:toBirText(birMod);"
j,"Job? j = self.jobs[id];"
nj,"Job nj = { id, result: () };"
cx,"CompileContext cx = new(basename);"
entryMod,"front:ResolvedModule entryMod = check processModule(cx, DEFAULT_ROOT_MODULE_ID, [entrySrc], emitter);"
scanned,"front:ScannedModule scanned = check front:scanModule(sourceParts, id);"
resolvedImports,"ResolvedImport[] resolvedImports = [];"
ri,"ResolvedImport ri = check resolveImport(cx, mod, emitter);"
mod,"front:ResolvedModule mod = check front:resolveModule(scanned, cx.env, resolvedImports);"
job,"Job job = cx.job(id);"
result,"var result = job.result;"
processed,"var processed = check processImport(cx, id, emitter);"
parts,"var parts = check subModuleSourceParts(cx.basename, id);"
mod,"front:ResolvedModule mod = check processModule(cx, id, parts, emitter);"
directory,"string directory = check file:joinPath(basename + \".modules\", subModuleSuffix(id));"
result,"map<bir:FunctionSignature> result = {};"
memberCount,"int memberCount = cx.random.nextRange(cx.bounds.maxMemberCount);"
restProposition,"SubtypeProposition restProposition = generateSubtypeProposition(cx, propositionBranch(path));"
left,"int left = cx.types.list(subtypes, rest = restProposition.left);"
right,"int right = cx.types.list(supertypes, rest = restProposition.right);"
rest,"SubtypeProposition rest = generateSubtypeProposition(cx, propositionBranch(path));"
left,"int left = cx.types.list(subtypes, rest = rest.left);"
sliceIndex,"int sliceIndex = cx.random.nextRange(supertypes.length());"
superMembers,"int[] superMembers = supertypes.slice(0, sliceIndex);"
superRest,"int superRest = rest.right;"
right,"int right = cx.types.list(superMembers, rest = superRest);"
p,"SubtypeProposition p = generateSubtypeProposition(cx, propositionBranch(path));"
left,"int left = cx.types.list(rest = p.left);"
right,"int right = t:NEVER;"
members,"int[] members = [];"
t,"int t = cx.types.neverType();"
rest,"int rest = -1;"
generator,"SubtypePropositionGenerator generator = AXIOMATIC_SUBTYPE_PROPOSITION_GENERATORS[cx.random.nextRange(AXIOMATIC_GENERATOR_COUNT)];"
prop,"SubtypeProposition prop = generator(cx, path);"
r,"int r = cx.random.nextRange(SUBTYPE_PROPOSITION_GENERATORS.length());"
generator,"SubtypePropositionGenerator generator = SUBTYPE_PROPOSITION_GENERATORS[r];"
subtypes,"int[] subtypes = [];"
supertypes,"int[] supertypes = [];"
p,"SubtypeProposition p = generateSubtypeProposition(cx, path);"
left,"int left = cx.types.mapping(rest = p.left);"
right,"int right = cx.types.mapping(rest = p.right);"
p1,"SubtypeProposition p1 = generateSubtypeProposition(cx, propositionBranch(path));"
p2,"SubtypeProposition p2 = generateSubtypeProposition(cx, propositionBranch(path));"
left,"int left = cx.types.union(cx.types.mapping(rest = p2.left), cx.types.mapping(rest = p2.left));"
right,"int right = cx.types.mapping(rest = cx.types.union(p1.right, p2.right));"
left,"int left = cx.types.mapping(subFields);"
right,"int right = cx.types.mapping(superFields);"
left,"int left = cx.types.mapping(subFields, rest.left);"
right,"int right = cx.types.mapping(superFields, rest.right);"
subFields,"Field[] subFields = [];"
superFields,"Field[] superFields = [];"
len,"int len = cx.random.nextRange(cx.bounds.maxStringConstLen);"
label,"string label = cx.random.randomStringValue(len);"
subtypeProp,"SubtypeProposition subtypeProp = generateSubtypeProposition(cx, { depth: 0, rands: [] });"
left,"NonEmptyProposition left = generateNonEmptyProposition(cx, propositionBranch(path));"
right,"NonEmptyProposition right = generateNonEmptyProposition(cx, propositionBranch(path));"
base,"NonEmptyProposition base = generateNonEmptyProposition(cx, propositionBranch(path));"
elem,"int elem = base.left;"
t,"int t = cx.types.list(rest = elem);"
rest,"int rest = base.left;"
fixedMembers,"int[] fixedMembers = from var _ in 0 ... cx.random.nextRange(cx.bounds.maxMemberCount) let var prop = generateNonEmptyProposition(cx, propositionBranch(path)) select prop.left;"
t,"int t = cx.types.list(fixedMembers, rest = rest);"
t,"int t = cx.types.list(fixedMembers);"
generator,"NonEmptyPropositionGenerator generator = AXIOMATIC_NONEMPTY_PROPOSITION_GENERATORS[cx.random.nextRange(AXIOMATIC_NONEMPTY_PROPOSITION_GENERATORS.length())];"
r,"int r = cx.random.nextRange(NONEMPTY_PROPOSITION_GENERATORS.length());"
generator,"NonEmptyPropositionGenerator generator = NONEMPTY_PROPOSITION_GENERATORS[r];"
prop,"NonEmptyProposition prop = generator(cx, path);"
left,"t:SemType left = cx.types.semtype(p.left);"
right,"t:SemType right = cx.types.semtype(p.right);"
result,"boolean? result = ();"
failureCount,"int failureCount = cx.failedPropositions.length();"
seed,"time:Utc seed = time:utcNow();"
cx,"PropositionGenContext cx = new PropositionGenContext(t:typeContext(new), seed[0]);"
generator,"PropositionGenerator generator = config.generator;"
prop,"Proposition prop = generator(cx, { depth, rands: [] });"
onFail,"PropositionTestOnFail? onFail = config.onFail;"
name,"string name = \"T\" + index.toString();"
vis,"s:Visibility vis = \"public\";"
defn,"s:TypeDefn defn = { startPos, endPos, name, td, namePos: startPos, vis, part: self.modulePart };"
qNamePos,"s:Position qNamePos = startPos;"
t,"t:SemType? t = self.defns[index].semType;"
ret,"error? ret = f:resolveModuleDefFromPart(self.cx, self.modulePart, self.getName(index));"
index,"int? index = self.byteIndex;"
index,"int? index = self.decimalIndex;"
index,"int? index = self.floatIndex;"
index,"int? index = self.intIndex;"
name,"string name = \"Signed\" + bits.toString();"
constituentRef,"s:TypeDescRef constituentRef = self.createTypeDescRef(constituentType);"
td,"s:XmlSequenceTypeDesc td = { startPos, endPos, pos:startPos, constituent: constituentRef };"
index,"int? index = self.xmlIndex;"
td,"s:BuiltinTypeDesc td = { startPos, endPos, builtinTypeName: \"xml\" };"
element,"s:TypeDescRef element = self.createQualifiedTypeDescRef(\"Element\", \"xml\");"
comment,"s:TypeDescRef comment = self.createQualifiedTypeDescRef(\"Comment\", \"xml\");"
pi,"s:TypeDescRef pi = self.createQualifiedTypeDescRef(\"ProcessingInstruction\", \"xml\");"
pi,"s:TypeDescRef pi = self.createQualifiedTypeDescRef(\"Text\", \"xml\");"
m,"s:TypeDescRef[] m = from var index in members select self.createTypeDescRef(index);"
restDesc,"s:TypeDescRef? restDesc = rest == -1 ? () : self.createTypeDescRef(rest);"
td,"s:TypeDesc td;"
size,"s:ExtendedLiteralExpr size = { startPos, endPos, base: 10, digits: fixedLen.toString() };"
fs,"s:FieldDesc[] fs = from var { name, index, ro } in fields select self.createField(name, index, ro);"
r,"s:TypeDesc? r = ();"
td,"s:MappingTypeDesc td = { startPos, endPos, fields: fs, rest: r };"
typeDesc,"s:TypeDescRef typeDesc = self.createTypeDescRef(index);"
index,"int? index = self.neverIndex;"
valueExpr,"s:ExtendedLiteralExpr valueExpr;"
desc,"s:SingletonTypeDesc desc = { startPos, endPos, valueExpr };"
index,"int? index = self.stringIndex;"
tds,"s:TypeDesc[] tds = [self.createTypeDescRef(i1), self.createTypeDescRef(i2)];"
union,"s:BinaryTypeDesc union = { startPos, endPos, opPos: [startPos], op: \"|\", tds };"
loc,"d:Location loc = err.detail().location;"
filename,"string filename = loc.file.filename();"
lc,"d:LineColumn lc = d:locationLineColumn(loc);"
modulePath,"string? modulePath = check moduleDir(path);"
errorLocation,"FilenameLine? errorLocation = ();"
subModPath,"string subModPath = filePath.substring(0, filePath.length()-4) + \".modules\";"
fileErrorLine,"int? fileErrorLine = check errorLine(filePath);"
cases,"TestSuiteCases cases = {};"
category,"string category = check file:basename(dir.absPath);"
name,"string name = check file:basename(test.absPath);"
dash,"int? dash = base.lastIndexOf(\"-\");"
testKind,"string testKind = base.substring(1 + <int>dash);"
lineNo,"int? lineNo = ();"
test,"s:TypeTest test = check s:parseTypeTest(item);"
left,"t:SemType left = resolveTestSemtype(tc, m, test.left);"
right,"t:SemType right = resolveTestSemtype(tc, m, test.right);"
lhsStr,"string lhsStr = test.left.toString();"
rhsStr,"string rhsStr = test.right.toString();"
lsr,"boolean lsr = t:isSubtype(tc, left, right);"
rsl,"boolean rsl = t:isSubtype(tc, right, left);"
testPair,"boolean[2] testPair = [lsr, rsl];"
t,"t:SemType t = lookupSemtype(m, tn.identifier);"
index,"int|s:Identifier index = tn.index;"
kt,"t:SemType kt = lookupSemtype(m, index);"
s1,"t:SemType s1 = t:listProjInnerVal(tc, t, index);"
s2,"t:SemType s2 = t:listMemberTypeInnerVal(tc, t, index);"
t,"t:SemType? t = m[id];"
r,"t:Range r = ranges[i];"
it,"t:SemType it = types[i];"
projected,"t:SemType projected = t:listMemberTypeInnerVal(tc, t, t:intConst(r.min));"
birText,"string birText = check tback:toBirText(birMod);"
firstRoundLl,"string firstRoundLl = firstRoundLlMod.printModuleToString();"
secondRoundSexpr,"sexpr:Data[] secondRoundSexpr = checkpanic sexpr:parse(birText);"
secondRoundTypeSexpr,"bsexpr:Module secondRoundTypeSexpr = checkpanic secondRoundSexpr.cloneWithType();"
secondRoundBirMod,"bir:Module secondRoundBirMod = bsexpr:toModule(secondRoundTypeSexpr, birMod.getId());"
secondRoundLl,"string secondRoundLl = secondRoundLlMod.printModuleToString();"
outputBasename,"string outputBasename = check chooseOutputBasename(basename, opts.outDir);"
emitter,"Emitter emitter;"
err,"CompileError? err = compileBalFile({ filename }, basename, emitter);"
files,"string files = errorFileCount == 1 ? \"file\" : \"files\";"
extIndex,"int? extIndex = filename.lastIndexOf(\".\");"
entries,"var entries = from var [name, t] in m.entries() order by name select [name, t];"
results,"[string, string][] results = [];"
rels,"string[] rels = from var [name1, name2] in results let string s = name1 + \"<:\" + name2 order by s select s;"
val,"Metadata val = intAsMetadata(self.context, flag[1]);"
dBuilder,"DIBuilder? dBuilder = self.diBuilder;"
bytePointer,"BytePointer bytePointer = new (jLLVMPrintModuleToString(self.LLVMModule));"
e,"byte[] e = [];"
err,"handle err = checkpanic jarrays:toHandle(e, \"byte\");"
runtimeMemBuffer,"LLVMMemoryBuffer runtimeMemBuffer = new;"
libModule,"Module libModule = new(\"balrt_inline\", self.context);"
result,"int result = jLLVMLinkModules2(self.LLVMModule, libModule.LLVMModule);"
result,"int result = jLLVMParseBitcodeInContext2(self.context.LLVMContext, memoryBuffer.jObject, self.LLVMModule);"
optLevel,"string optLevel = opts.optLevel ?: \"Default\";"
relocMode,"string relocMode = opts.relocMode ?: \"PIC\";"
codeModel,"string codeModel = opts.codeModel ?: \"Default\";"
file,"BytePointer file = new(jBytePointerFromString(java:fromString(fileName)));"
targetTriple,"BytePointer targetTriple;"
jTargetRef,"handle jTargetRef = jLLVMGetFirstTarget();"
lookupError,"BytePointer lookupError = new(jBytePointer());"
isLookUpError,"int isLookUpError = jLLVMGetTargetFromTriple(targetTriple.jObject, jTargetRef, lookupError.jObject);"
cpu,"BytePointer cpu = new(jBytePointerFromString(java:fromString(\"generic\")));"
features,"BytePointer features = new(jBytePointerFromString(java:fromString(\"\")));"
llvmOptLevel,"int llvmOptLevel = getLLVMCodeGenOptLevel(optLevel);"
jTargetMachineRef,"handle jTargetMachineRef = jLLVMCreateTargetMachine(jTargetRef, targetTriple.jObject, cpu.jObject, features.jObject, llvmOptLevel, getLLVMRelocMode(relocMode), getLLVMCodeModel(codeModel));"
emitError,"BytePointer emitError = new(jBytePointer());"
isEmitError,"int isEmitError = jLLVMTargetMachineEmitToFile(jTargetMachineRef, self.LLVMModule, file.jObject, 1, emitError.jObject);"
functionPasses,"handle functionPasses = jLLVMCreateFunctionPassManager(jLLVMCreateModuleProviderForExistingModule(self.LLVMModule));"
modulePasses,"handle modulePasses = jLLVMCreatePassManager();"
targetDataRef,"handle targetDataRef = jLLVMCreateTargetDataLayout(jTargetMachineRef);"
targetDataBP,"handle targetDataBP = jLLVMCopyStringRepOfTargetData(targetDataRef);"
val,"ConstPointerValue val = new (jLLVMAddGlobalInAddressSpace(self.LLVMModule, typeToLLVMType(self.context, ty), java:fromString(name), props.addressSpace), pointerType(ty, props.addressSpace));"
initializer,"var initializer = props.initializer;"
val,"ConstPointerValue val = new(jLLVMAddAlias(self.LLVMModule, typeToLLVMType(self.context, aliasTy), props.addressSpace, aliasee.LLVMValueRef, java:fromString(name)), pointerType(aliasTy, props.addressSpace));"
id,"int id = intrinsicNameToId(name);"
fnType,"FunctionType fnType = name is IntegerArithmeticIntrinsicName ? {returnType: structType([\"i64\", \"i1\"]), paramTypes: [\"i64\", \"i64\"]} : {returnType: pointerType(\"i8\", 1), paramTypes: [pointerType(\"i8\", 1), \"i64\"]};"
paramTypes,"PointerPointer paramTypes = PointerPointerFromTypes(self.context, fnType.paramTypes);"
paramCount,"int paramCount = fnType.paramTypes.length();"
optimized,"int optimized = getBooleanProp(props.isOptimized);"
kind,"int kind = emissionKindToInt.get(props.kind);"
DWOId,"int DWOId = getIntProp(props.DWOId);"
splitDebugInlining,"int splitDebugInlining = getBooleanProp(props.splitDebugInlining);"
splitDebugInfoForProfiling,"int splitDebugInfoForProfiling = getBooleanProp(props.splitDebugInfoForProfiling);"
jObj,"handle jObj = jLLVMDIBuilderCreateCompileUnit(self.LLVMDIBuilder, lang, file, producer, producerLen, optimized, flags, flagsLen, props.runtimeVersion, splitName, splitNameLen, kind, DWOId, splitDebugInlining, splitDebugInfoForProfiling, sysRoot, sysRootLen, sdk, sdkLen);"
jObj,"handle jObj = jLLVMDIBuilderCreateFile(self.LLVMDIBuilder, filenameObj, filenameLen, dir, dirLen);"
scope,"handle scope = getMetadataProp(props.scope);"
file,"handle file = getMetadataProp(props.file);"
ty,"handle ty = getMetadataProp(props.ty);"
isLocalToUnit,"int isLocalToUnit = getBooleanProp(props.isLocalToUnit);"
isDefinition,"int isDefinition = getBooleanProp(props.isDefinition);"
flag,"int flag = dIFlagToInt.get(props.flag);"
isOptimized,"int isOptimized = getBooleanProp(props.isOptimized);"
jObj,"handle jObj = jLLVMDIBuilderCreateFunction(self.LLVMDIBuilder, scope, name, nameLen, linkageName, linkageNameLen, file, props.lineNo, ty, isLocalToUnit, isDefinition, props.scopeLine, flag, isOptimized);"
fileObj,"handle fileObj = getMetadataProp(file);"
parameterArr,"PointerPointer parameterArr = PointerPointerFromMetadata(parameterTypes);"
flagObj,"int flagObj = dIFlagToInt.get(flag);"
jObj,"handle jObj = jLLVMDIBuilderCreateSubroutineType(self.LLVMDIBuilder, fileObj, parameterArr.jObject, parameterTypes.length(), flagObj);"
scopeJObj,"handle scopeJObj = getMetadataProp(scope);"
inlinedAtJObj,"handle inlinedAtJObj = getMetadataProp(inlinedAt);"
jObj,"handle jObj = jLLVMDIBuilderCreateDebugLocation(self.context.LLVMContext, line, column, scopeJObj, inlinedAtJObj);"
align,"int align = getIntProp(props.alignInBits);"
jObj,"handle jObj = jLLVMDIBuilderCreatePointerType(self.LLVMDIBuilder, props.pointeeTy.llvmMetadata, props.sizeInBits, align, props.addressSpace, tyName, nameLen);"
align,"int align = getIntProp(alignInBits);"
jObj,"handle jObj = jLLVMDIBuilderCreateTypedef(self.LLVMDIBuilder, ty.llvmMetadata, tyName, nameLen, file.llvmMetadata, lineNo, scope.llvmMetadata, align);"
encoding,"int encoding = encodingToInt.get(props.encoding);"
flags,"int flags = dIFlagToInt.get(props.flag);"
jObj,"handle jObj = jLLVMDIBuilderCreateBasicType(self.LLVMDIBuilder, tyName, nameLen, props.sizeInBits, encoding, flags);"
jObj,"handle jObj = jLLVMDIBuilderCreateAutoVariable(self.LLVMDIBuilder, props.scope.llvmMetadata, name, nameLen, props.file.llvmMetadata, props.lineNo, props.ty.llvmMetadata, 1, flags, align);"
jObj,"handle jObj = jLLVMDIBuilderCreateExpression(self.LLVMDIBuilder, checkpanic jarrays:toHandle(addr, \"long\"), addr.length());"
jObj,"handle jObj = jLLVMDIBuilderCreateLexicalBlock(self.LLVMDIBuilder, scope.llvmMetadata, file.llvmMetadata, line, column);"
encodingData,"Encoding encodingData = encodingMap.hasKey(key) ? encodingMap.get(key) : defaultEncoding;"
recordArray,"string[] recordArray = [];"
nextParent,"string nextParent = parent + \"[\" + key + \"]\";"
key,"string key = arrayName;"
arrayValues,"string[] arrayValues = [];"
serializedArray,"string[] serializedArray = [];"
arayIndex,"int arayIndex = 0;"
encoded,"string|error encoded = url:encode(value.toString(), \"UTF8\");"
param,"string[] param = [];"
restOfPath,"string restOfPath = string:'join(\"\", ...param);"
headerMap,"map<string|string[]> headerMap = {};"
stringArray,"string[] stringArray = [];"
message,"Point message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"routeguide.RouteGuide/GetFeature\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"routeguide.RouteGuide/RecordRoute\");"
message,"Rectangle message;"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"routeguide.RouteGuide/ListFeatures\", message, headers);"
outputStream,"FeatureStream outputStream = new FeatureStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"routeguide.RouteGuide/RouteChat\");"
response,"var response = check self.sClient->receive();"
nextRecord,"record {|Feature value;|} nextRecord = {value: <Feature>streamValue.value};"
personInfo,"var personInfo = from var {id: personId, fname: firstName, lname: lastName} in personList select { id: personId, name: firstName + \" \" + lastName };"
profession,"var profession = \"Software Engineer\";"
greeting,"string greeting = \"Hello World\";"
response,"var response = check int:fromString(\"404\");"
message,"SMReq message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"SeparateModuleService/unary\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"SeparateModuleService/clientStreaming\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"SeparateModuleService/serverStreaming\", message, headers);"
outputStream,"SMResStream outputStream = new SMResStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"SeparateModuleService/bidirectional1\");"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"SeparateModuleService/bidirectional2\");"
nextRecord,"record {|SMRes value;|} nextRecord = {value: <SMRes>streamValue.value};"
outputStream,"StringStream outputStream = new StringStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"HelloWorld/lotsOfReplies\", req);"
nextRecord,"record {| string value; |} nextRecord = {value: <string>streamValue.value};"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld/hello\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld/helloWorld\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloBallerina/helloBallerina\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloWorld/sayHello\", message, headers);"
message,"message1:ReqMessage1 message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"packaging.packagingService/hello1\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"packaging.packagingService/hello3\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"packaging.packagingService/hello2\", message, headers);"
outputStream,"ResMessage2Stream outputStream = new ResMessage2Stream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"packaging.packagingService/hello4\");"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"packaging.packagingService/hello5\");"
nextRecord,"record {|message2:ResMessage2 value;|} nextRecord = {value: <message2:ResMessage2>streamValue.value};"
message,"ReqMessage message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"packaging.helloBallerina71/hi\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"packaging.helloBallerina71/hello\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"packaging.helloBallerina71/hey\", message, headers);"
outputStream,"ResMessageStream outputStream = new ResMessageStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"packaging.helloBallerina71/bye\");"
nextRecord,"record {|ResMessage value;|} nextRecord = {value: <ResMessage>streamValue.value};"
message,"message1:ReqMessage message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"packaging.helloWorld70/helloWorld70Unary\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"packaging.helloWorld70/helloWorld70ClientStream\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"packaging.helloWorld70/helloWorld70ServerStream\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"packaging.helloWorld70/helloWorld70BidiStream\");"
nextRecord,"record {|message2:ResMessage value;|} nextRecord = {value: <message2:ResMessage>streamValue.value};"
message,"messageWithService:ReqMessage message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"packaging.helloWorld71/helloWorld71Unary\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"packaging.helloWorld71/helloWorld71ClientStream\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"packaging.helloWorld71/helloWorld71ServerStream\", message, headers);"
outputStream,"messageWithService:ResMessageStream outputStream = new messageWithService:ResMessageStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"packaging.helloWorld71/helloWorld71BidiStream\");"
message,"Order message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"ecommerce.OrderManagement/addOrder\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"ecommerce.OrderManagement/getOrder\", message, headers);"
outputStream,"Int32ArrMsgStream outputStream = new Int32ArrMsgStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DataTypesService/helloWithInt32Array\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DataTypesService/helloWithInt64Array\", message, headers);"
outputStream,"Int64ArrMsgStream outputStream = new Int64ArrMsgStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DataTypesService/helloWithUnsignedInt64Array\", message, headers);"
outputStream,"UnsignedInt64ArrMsgStream outputStream = new UnsignedInt64ArrMsgStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DataTypesService/helloWithFixed32Array\", message, headers);"
outputStream,"Fixed32ArrMsgStream outputStream = new Fixed32ArrMsgStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DataTypesService/helloWithFixed64Array\", message, headers);"
outputStream,"Fixed64ArrMsgStream outputStream = new Fixed64ArrMsgStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DataTypesService/helloWithFloatArray\", message, headers);"
outputStream,"FloatArrMsgStream outputStream = new FloatArrMsgStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DataTypesService/helloWithDoubleArray\", message, headers);"
outputStream,"DoubleArrMsgStream outputStream = new DoubleArrMsgStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DataTypesService/helloWithStringArray\", message, headers);"
outputStream,"StringArrMsgStream outputStream = new StringArrMsgStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DataTypesService/helloWithBooleanArray\", message, headers);"
outputStream,"BooleanArrMsgStream outputStream = new BooleanArrMsgStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DataTypesService/helloWithBytesArray\", message, headers);"
outputStream,"BytesArrMsgStream outputStream = new BytesArrMsgStream(result);"
nextRecord,"record {|Int32ArrMsg value;|} nextRecord = {value: <Int32ArrMsg>streamValue.value};"
nextRecord,"record {|Int64ArrMsg value;|} nextRecord = {value: <Int64ArrMsg>streamValue.value};"
nextRecord,"record {|UnsignedInt64ArrMsg value;|} nextRecord = {value: <UnsignedInt64ArrMsg>streamValue.value};"
nextRecord,"record {|Fixed32ArrMsg value;|} nextRecord = {value: <Fixed32ArrMsg>streamValue.value};"
nextRecord,"record {|Fixed64ArrMsg value;|} nextRecord = {value: <Fixed64ArrMsg>streamValue.value};"
nextRecord,"record {|FloatArrMsg value;|} nextRecord = {value: <FloatArrMsg>streamValue.value};"
nextRecord,"record {|DoubleArrMsg value;|} nextRecord = {value: <DoubleArrMsg>streamValue.value};"
nextRecord,"record {|StringArrMsg value;|} nextRecord = {value: <StringArrMsg>streamValue.value};"
nextRecord,"record {|BooleanArrMsg value;|} nextRecord = {value: <BooleanArrMsg>streamValue.value};"
nextRecord,"record {|BytesArrMsg value;|} nextRecord = {value: <BytesArrMsg>streamValue.value};"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld14/hello\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"AnonService1/hello1\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"AnonService1/hello2\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"AnonService2/hello1\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"AnonService2/hello2\", message, headers);"
outputStream,"swrappers:StringStream outputStream = new swrappers:StringStream(result);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"AnonService3/hello1\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"AnonService3/hello2\");"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"AnonService4/hello1\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"AnonService4/hello2\");"
message,"AnyArrayRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"RepeatedTypesService/anyCall\", message, headers);"
message,"StructArrayRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"RepeatedTypesService/structCall\", message, headers);"
message,"TimestampArrayRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"RepeatedTypesService/timestampCall\", message, headers);"
message,"DurationArrayRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"RepeatedTypesService/durationCall\", message, headers);"
message,"'any:Any message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"AnyTypeServer/unaryCall1\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"AnyTypeServer/unaryCall2\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"AnyTypeServer/unaryCall3\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"AnyTypeServer/clientStreamingCall\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"AnyTypeServer/serverStreamingCall\", message, headers);"
outputStream,"sany:AnyStream outputStream = new sany:AnyStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"AnyTypeServer/bidirectionalStreamingCall\");"
message,"AnyMessageRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"PredefinedTypesInService/anyCall\", message, headers);"
message,"StructMessageRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"PredefinedTypesInService/structCall\", message, headers);"
message,"TimestampMessageRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"PredefinedTypesInService/timestampCall\", message, headers);"
message,"DurationMessageRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"PredefinedTypesInService/durationCall\", message, headers);"
message,"HelloRequest58 message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloWorldWithNestedMessageNestedEnum/hello\", message, headers);"
message,"ByeRequest58 message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"helloWorldWithNestedMessageNestedEnum/bye\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld52/testStringValueReturn\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld29/testStringValueReturn\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld29/testStringValueReturnNegative\", message, headers);"
message,"byte[] message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.ByteService/checkBytes\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld36S1/call1\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld36S2/call2\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"TimestampService/getGreeting\", message, headers);"
message,"Greeting message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"TimestampService/exchangeGreeting\", message, headers);"
message,"time:Utc message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"TimestampService/exchangeTime\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"TimestampService/clientStreamTime\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"TimestampService/serverStreamTime\", message, headers);"
outputStream,"stimestamp:TimestampStream outputStream = new stimestamp:TimestampStream(result);"
message,"HandshakeRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"Negotiator/handshake\", message, headers);"
message,"MetricsPublishRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"Negotiator/publishMetrics\", message, headers);"
message,"TracesPublishRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"Negotiator/publishTraces\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"NestedMsgService/nestedMsgUnary\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"NestedMsgService/nestedMsgClientStreaming\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"NestedMsgService/nestedMsgServerStreaming\", message, headers);"
outputStream,"NestedMsgStream outputStream = new NestedMsgStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"NestedMsgService/nestedMsgBidirectionalStreaming\");"
nextRecord,"record {|NestedMsg value;|} nextRecord = {value: <NestedMsg>streamValue.value};"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.GrpcMutualSslService/hello\", message, headers);"
message,"ProductDetail message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"ecommerce.ProductInfo/addProduct\", message, headers);"
message,"ProductID message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"ecommerce.ProductInfo/getProduct\", message, headers);"
message,"MessageInfo message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"MessageService/UnaryCall\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.CheckoutService/PlaceOrder\", message, headers);"
message,"TestInt message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld3/testIntArrayInput\", message, headers);"
message,"TestString message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld3/testStringArrayInput\", message, headers);"
message,"TestFloat message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld3/testFloatArrayInput\", message, headers);"
message,"TestBoolean message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld3/testBooleanArrayInput\", message, headers);"
message,"TestStruct message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld3/testStructArrayInput\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld3/testIntArrayOutput\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld3/testStringArrayOutput\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld3/testFloatArrayOutput\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld3/testBooleanArrayOutput\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld3/testStructArrayOutput\", message, headers);"
message,"SimpleRequestWithAnnotation message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"SimpleServiceWithAnnotation/unaryCallWithAnnotatedData\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"SimpleServiceWithAnnotation/clientStreamingWithAnnotatedData\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"SimpleServiceWithAnnotation/serverStreamingWithAnnotatedData\", message, headers);"
outputStream,"SimpleResponseWithAnnotationStream outputStream = new SimpleResponseWithAnnotationStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"SimpleServiceWithAnnotation/bidirectionalStreamingWithAnnotatedData\");"
nextRecord,"record {|SimpleResponseWithAnnotation value;|} nextRecord = {value: <SimpleResponseWithAnnotation>streamValue.value};"
message,"OrderInfo message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.TestEnumService/testEnum\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld85/hello\", message, headers);"
outputStream,"HelloResponseStream outputStream = new HelloResponseStream(result);"
message,"HelloRequest message;"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"HelloWorldServerStreaming/lotsOfReplies\", message, headers);"
nextRecord,"record {|HelloResponse value;|} nextRecord = {value: <HelloResponse>streamValue.value};"
message,"TypesMessage message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"TypesService/getTypes\", message, headers);"
message,"RepeatedTypesMessage message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"TypesService/getRepeatedTypes\", message, headers);"
message,"int message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"TypesService/getInt32Type\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"TypesService/getInt64Type\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"TypesService/getUInt32Type\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"TypesService/getUInt64Type\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld50/checkCancellation\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"HelloWorld50/sendString\");"
message,"GetClassRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"UpdatedService/GetClass\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"UpdatedService/GetGroup\", message, headers);"
display_nameCount,"int display_nameCount = 0;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld16/hello\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"StructService/getStructType1\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"StructService/getStructType2\", message, headers);"
message,"map<anydata> message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"StructService/sendStructType1\", message, headers);"
message,"StructMsg message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"StructService/sendStructType2\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"StructService/exchangeStructType1\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"StructService/exchangeStructType2\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"StructService/clientStreamStructType1\");"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"StructService/clientStreamStructType2\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"StructService/serverStreamStructType1\", message, headers);"
outputStream,"sstruct:StructStream outputStream = new sstruct:StructStream(result);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"StructService/serverStreamStructType2\", message, headers);"
outputStream,"StructMsgStream outputStream = new StructMsgStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"StructService/bidirectionalStreamStructType1\");"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"StructService/bidirectionalStreamStructType2\");"
nextRecord,"record {|StructMsg value;|} nextRecord = {value: <StructMsg>streamValue.value};"
message,"Person message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld/testInputNestedStruct\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld/testOutputNestedStruct\", message, headers);"
message,"StockRequest message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld/testInputStructOutputStruct\", message, headers);"
message,"StockQuote message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld/testInputStructNoOutput\", message, headers);"
message,"Empty message = {};"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld/testNoInputOutputStruct\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld/testNoInputOutputArray\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld55/hello55UnaryWithCaller\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld55/hello55UnaryWithReturn\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"HelloWorld55/hello55ClientStreaming\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"HelloWorld55/hello55ServerStreaming\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"HelloWorld55/hello55BiDiWithCaller\");"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"HelloWorld55/hello55BiDiWithReturn\");"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld55EmptyScope/hello55EmptyScope\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld56/hello56Unary\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"HelloWorld56/hello56BiDi\");"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld24/testStringValueReturn\", message, headers);"
message,"float message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld24/testFloatValueReturn\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld24/testDoubleValueReturn\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld24/testInt64ValueReturn\", message, headers);"
message,"boolean message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld24/testBoolValueReturn\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld24/testBytesValueReturn\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld24/testRecordValueReturn\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"HelloWorld24/testRecordValueReturnStream\", message, headers);"
outputStream,"SampleMsg24Stream outputStream = new SampleMsg24Stream(result);"
nextRecord,"record {|SampleMsg24 value;|} nextRecord = {value: <SampleMsg24>streamValue.value};"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"grpcservices.HelloWorld45/lotsOfReplies\", message, headers);"
message,"SampleMsg31 message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld31/sayHello\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld28/testStringValueReturn\", message, headers);"
message,"Request1 message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.OneofFieldService/hello\", message, headers);"
message,"ZZZ message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.OneofFieldService/testOneofField\", message, headers);"
otherCount,"int otherCount = 0;"
nameCount,"int nameCount = 0;"
codeCount,"int codeCount = 0;"
valueCount,"int valueCount = 0;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld100/hello\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld100/testInt\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld100/testFloat\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld100/testBoolean\", message, headers);"
message,"Request message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld100/testStruct\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld100/testNoRequest\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld100/testNoResponse\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld100/testResponseInsideMatch\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.ProductCatalog/getProduct\", message, headers);"
message,"ChangedCustomer message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.ProductCatalog/sendCustomer\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"DurationHandler/unaryCall1\", message, headers);"
message,"DurationMsg message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"DurationHandler/unaryCall2\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"DurationHandler/clientStreaming\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"DurationHandler/serverStreaming\", message, headers);"
outputStream,"sduration:DurationStream outputStream = new sduration:DurationStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"DurationHandler/bidirectionalStreaming\");"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld30/testStringValueReturn\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld30/testStringValueNoScope\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld30/testStringValueNegative\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"HelloWorld53/hello53\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld51/sendStringBiDi\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"HelloWorld51/InvalidRPCCall\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"HelloWorld51/InvalidRPCCall\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"HelloWorld51/stringServerStreaming\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"HelloWorld51/InvalidRPCCall\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"grpcservices.HelloWorld25/lotsOfReplies\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld13/hello\", message, headers);"
message,"HSReq message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HeadersService/unary\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"HeadersService/clientStr\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"HeadersService/serverStr\", message, headers);"
outputStream,"HSResStream outputStream = new HSResStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"HeadersService/bidirectionalStr\");"
nextRecord,"record {|HSRes value;|} nextRecord = {value: <HSRes>streamValue.value};"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld73/hello73Unary\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"grpcservices.HelloWorld73/hello73Client\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"grpcservices.HelloWorld73/hello73Server\", message, headers);"
outputStream,"ReplyMessageStream outputStream = new ReplyMessageStream(result);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"grpcservices.HelloWorld73/hello73Bidi\");"
nextRecord,"record {|ReplyMessage value;|} nextRecord = {value: <ReplyMessage>streamValue.value};"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld98/hello1\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"grpcservices.HelloWorld98/testInt\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"EmptyHandler/clientStrWithEmpty\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"EmptyHandler/serverStrWithEmpty\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"messagesize.HelloWorld62/msgSizeUnary\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeClientStreaming(\"messagesize.HelloWorld62/msgSizeClientStreaming\");"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"messagesize.HelloWorld62/msgSizeServerStreaming\", message, headers);"
sClient,"grpc:StreamingClient sClient = check self.grpcClient->executeBidirectionalStreaming(\"messagesize.HelloWorld62/msgSizeBidiStreaming\");"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"PredefinedRecords/CallAny\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"PredefinedRecords/CallStruct\", message, headers);"
message,"time:Seconds message;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"PredefinedRecords/CallDuration\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"PredefinedRecords/CallTimestamp\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"PredefinedRecords/CallEmpty\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"RetryService/getResult\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld39/testStringValueReturn\", message, headers);"
err,"grpc:Error? err = conn->sendString(msg);"
msg,"string msg = string `${caller.getId()} left the chat`;"
conn,"ChatStringCaller conn;"
message,"ChatMessage41 message;"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"Chat41/call1\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"Chat41/call2\", message, headers);"
outputStream,"SampleMsg32Stream outputStream = new SampleMsg32Stream(result);"
message,"SampleMsg32 message;"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"HelloWorld32/sayHello\", message, headers);"
nextRecord,"record {|SampleMsg32 value;|} nextRecord = {value: <SampleMsg32>streamValue.value};"
message_requestCount,"int message_requestCount = 0;"
message_responseCount,"int message_responseCount = 0;"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld101/hello\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld35/callWithinDeadline\", message, headers);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"HelloWorld35/callExceededDeadline\", message, headers);"
payload,"var payload = check self.grpcClient->executeServerStreaming(\"routeguide.RouteGuide/ListFeatures\", req);"
payload,"var payload = check self.grpcClient->executeSimpleRPC(\"BalProgramAnalyzer/syntaxTree\", message, headers);"
stream_call_responseCount,"int stream_call_responseCount = 0;"
deadlineStringValue,"string|string[]? deadlineStringValue = headerMap[DEALINE_HEADER];"
deadline,"time:Utc deadline = check time:utcFromString(deadlineStringValue);"
data,"record {|Variable value;|}? data = check queryResult.next();"
variable,"Variable variable = data.value;"
data,"record {|Result value;|}? data = check queryResult.next();"
value,"Result value = data.value;"
payload,"string payload = string `grant_type=password&username=${username}&password=${password}`;"
requestConfig,"RequestConfig requestConfig;"
defaultTokenExpTime,"decimal defaultTokenExpTime = config.defaultTokenExpTime;"
clockSkew,"decimal clockSkew = config.clockSkew;"
clientConfig,"ClientConfiguration clientConfig = config.clientConfig;"
response,"json response = check sendRequest(requestConfig, tokenUrl, clientConfig);"
accessToken,"string accessToken = check extractAccessToken(response);"
refreshToken,"string? refreshToken = extractRefreshToken(response);"
expiresIn,"int? expiresIn = extractExpiresIn(response);"
encodedUserName,"string encodedUserName = check url:encode(username, UTF8);"
encodedPassword,"string encodedPassword = check url:encode(password, UTF8);"
tokenUrl,"string tokenUrl = config.tokenUrl;"
clientId,"string? clientId = config?.clientId;"
clientSecret,"string? clientSecret = config?.clientSecret;"
refreshConfig,"RefreshConfig refreshConfig = check getRefreshConfig(config);"
refreshToken,"string refreshToken = tokenCache.getRefreshToken();"
requestConfig,"RequestConfig requestConfig = { payload: \"grant_type=refresh_token&refresh_token=\" + refreshToken, clientId: clientId, clientSecret: clientSecret, scopes: refreshConfig?.scopes, optionalParams: refreshConfig?.optionalParams, credentialBearer: refreshConfig.credentialBearer };"
response,"json response = check sendRequest(requestConfig, refreshConfig.refreshUrl,refreshConfig.clientConfig);"
updatedRefreshToken,"string? updatedRefreshToken = extractRefreshToken(response);"
refreshConfig,"RefreshConfig|INFER_REFRESH_CONFIG? refreshConfig = config?.refreshConfig;"
refreshUrl,"string refreshUrl = config.refreshUrl;"
requestConfig,"RequestConfig requestConfig = { payload: \"grant_type=refresh_token&refresh_token=\" + refreshToken, clientId: config.clientId, clientSecret: config.clientSecret, scopes: config?.scopes, optionalParams: config?.optionalParams, credentialBearer: config.credentialBearer };"
response,"json response = check sendRequest(requestConfig, refreshUrl, clientConfig);"
refreshUrl,"string refreshUrl = config.tokenUrl;"
requestConfig,"RequestConfig requestConfig = { payload: \"grant_type=refresh_token&refresh_token=\" + refreshToken, clientId: clientId, clientSecret: clientSecret, scopes: config?.scopes, optionalParams: config?.optionalParams, credentialBearer: config.credentialBearer };"
headers,"map<string> headers = check prepareHeaders(requestConfig);"
payload,"string payload = check preparePayload(requestConfig);"
stringResponse,"string|Error stringResponse = doHttpRequest(url, clientConfig, headers, payload);"
jsonResponse,"json|error jsonResponse = stringResponse.fromJsonString();"
headers,"map<string> headers = {};"
clientIdSecret,"string clientIdSecret = clientId + \":\" + clientSecret;"
textPayload,"string textPayload = config.payload;"
scopeString,"string scopeString = \"\";"
scopes,"string|string[]? scopes = config.scopes;"
trimmedRequestScope,"string trimmedRequestScope = requestScope.trim();"
optionalParams,"map<string>? optionalParams = config.optionalParams;"
accessToken,"json|error accessToken = response.access_token;"
refreshToken,"json|error refreshToken = response.refresh_token;"
expiresIn,"json|error expiresIn = response.expires_in;"
currentTime,"[int, decimal] currentTime = time:utcNow();"
issueTime,"int issueTime = currentTime[0];"
customHeadersMap,"map<string> customHeadersMap = {};"
oauth2Provider,"ClientOAuth2Provider? oauth2Provider = clientOAuth2Provider;"
accessToken,"string|Error accessToken = oauth2Provider.generateToken();"
stringResponse,"string|Error stringResponse = doHttpRequest(config.url, config.clientConfig, customHeadersMap, textPayload);"
introspectionResponse,"IntrospectionResponse introspectionResponse = { active: false };"
payloadMap,"map<json> payloadMap = <map<json>>payload;"
keys,"string[] keys = payloadMap.keys();"
result,"cache:Error? result;"
cachedEntry,"any|cache:Error cachedEntry = oauth2Cache.get(token);"
response,"IntrospectionResponse response = <IntrospectionResponse> cachedEntry;"
expTime,"int? expTime = response?.exp;"
result,"cache:Error? result = oauth2Cache.invalidate(token);"
dbClient1,"Client dbClient1 = check new (host, user, password, database, port, options);"
dbClient2,"Client dbClient2 = check new (host, user, password, database, port, options);"
dbClient3,"Client dbClient3 = check new (host, user, password, database, port, options);"
dbClient4,"Client dbClient4 = check new (host, user, password, database, port, options);"
dbClient5,"Client dbClient5 = check new (host, user, password, database, port, options);"
resultArray,"stream<Result, error?>[] resultArray = [];"
encoded,"string|error encoded = url:encode(value, UTF8);"
stringWithUnderScore,"string stringWithUnderScore = regex:replaceAll(camelCaseString, \"([A-Z])\", \"_$1\");"
updateQuery,"string updateQuery = createQuery(message);"
url,"string url = UPDATE_MESSAGE_PATH + channelId + updateQuery;"
response,"http:Response response = check slackClient->post(<@untainted> url, EMPTY_STRING);"
payload,"json payload = check response.getJsonPayload();"
threadId,"json threadId = check payload.ts;"
response,"http:Response|error response = slackClient->post(url, EMPTY_STRING);"
ok,"json ok = check payload.ok;"
ch,"var ch = payload.'channel;"
slackCh,"Channel|error slackCh = ch.cloneWithType(Channel);"
url,"string url = CONVERSATIONS_JOIN_PATH + channelId;"
url,"string url = LEAVE_CHANNEL_PATH + channelId;"
url,"string url = GET_USER_INFO_PATH + userId;"
response,"http:Response response = check slackClient->get(url);"
userInfo,"json userInfo = check response.getJsonPayload();"
user,"json user = check userInfo.user;"
url,"string url = RENAME_CHANNEL_PATH + channelId + NAME_ARG + newName;"
ok,"json|error ok = respPayload.ok;"
errorRes,"json|error errorRes = respPayload.'error;"
url,"string url = DELETE_CONVERSATION_PATH + channelId + DELETE_CONVERSATION_TS_ARG + threadTs;"
url,"string url = DELETE_FILE_PATH + fileId;"
url,"string url = LIST_FILES_PATH;"
response,"http:Response response = check slackClient->post(url, EMPTY_STRING);"
fileList,"json fileList = check response.getJsonPayload();"
files,"json files = check fileList.files;"
fileJson,"json[] fileJson = <json[]> files;"
url,"string url = UPLOAD_FILES_PATH;"
request,"http:Request request = new;"
filePart,"mime:Entity filePart = new;"
bodyParts,"mime:Entity[] bodyParts = [<@untainted> filePart];"
response,"http:Response response = check slackClient->post(url, request);"
fileInfo,"json fileInfo = check response.getJsonPayload();"
fileInfoPayload,"json fileInfoPayload = fileInfo;"
file,"json file = check fileInfoPayload.file;"
url,"string url = GET_FILE_INFO_PATH + fileId;"
fileJson,"json fileJson = <json> check fileInfo.file;"
contentDisposition,"mime:ContentDisposition contentDisposition = new;"
lastIndex,"int? lastIndex = string:lastIndexOf(filePath, BACK_SLASH);"
mapValue,"map<json> mapValue = <map<json>>req;"
converted,"string converted = convertToCamelCase(key);"
innerJson,"json[] innerJson = <json[]>mapValue[converted];"
returnResult,"string returnResult = \"\";"
splitResult,"string[] splitResult = regex:split(input, \"_\");"
participantId,"string participantId = participant.participantId;"
notifyResult,"NotifyResult|error notifyResult = (action == COMMAND_COMMIT) ? NOTIFY_RESULT_COMMITTED : NOTIFY_RESULT_ABORTED;"
results,"future<(NotifyResult|error)?>?[] results = [];"
participantArr,"var participantArr = self.participants.toArray();"
participant,"var participant = participantArr[i];"
f,"future<(NotifyResult|error)?> f = @strand{thread:\"any\"} start participant.notify(action, protocolName);"
j,"int j = 0;"
r,"var r = results[j];"
f,"future<(NotifyResult|error)?> f;"
result,"(NotifyResult|error)? result = wait f;"
ret,"string|lang_trx:Error ret = \"\";"
result,"var result = self.notifyParticipants(COMMAND_ABORT, ());"
localAbortSuccessful,"boolean localAbortSuccessful = abortResourceManagers(self.transactionId, self.transactionBlockId);"
removed,"var removed = trap self.participants.remove(participantId);"
value,"anydata value = v is Valuer ? v() : v;"
spanContext,"map<string> spanContext = observe:getSpanContext();"
logOutput,"string logOutput = format == JSON_OUTPUT_FORMAT ? logRecord.toJsonString() : printLogFmt(logRecord);"
path,"string? path = ();"
output,"string output = logOutput;"
result,"io:Error? result = io:fileWriteString(path, output + \"\n\", io:APPEND);"
message,"string message = \"\";"
value,"string value;"
temp,"handle temp = replaceString(java:fromString(msg), java:fromString(\"\\\"), java:fromString(\"\\\\\"));"
updatedString,"string? updatedString = java:toString(temp);"
moduleLogLevel,"string moduleLogLevel = level;"
module,"Value module = keyValues[\"module\"];"
encodedJwtComponents,"string[] encodedJwtComponents = check getJwtComponents(jwt);"
header,"Header header = check getHeader(encodedJwtComponents[0]);"
payload,"Payload payload = check getPayload(encodedJwtComponents[1]);"
jwtComponents,"string[] jwtComponents = regex:split(jwt, \"\\.\");"
decodedHeader,"byte[]|Error decodedHeader = decodeBase64Url(encodedHeader);"
result,"string|error result = 'string:fromBytes(decodedHeader);"
jsonHeader,"json|error jsonHeader = result.fromJsonString();"
decodedPayload,"byte[]|Error decodedPayload = decodeBase64Url(encodedPayload);"
result,"string|error result = 'string:fromBytes(decodedPayload);"
jsonPayload,"json|error jsonPayload = result.fromJsonString();"
signature,"byte[]|Error signature = decodeBase64Url(encodedSignature);"
header,"Header header = {};"
keys,"string[] keys = headerMap.keys();"
payload,"Payload payload = {};"
exp,"string exp = payloadMap[key].toString();"
value,"int|error value = 'int:fromString(exp);"
nbf,"string nbf = payloadMap[key].toString();"
value,"int|error value = 'int:fromString(nbf);"
iat,"string iat = payloadMap[key].toString();"
value,"int|error value = 'int:fromString(iat);"
alg,"SigningAlgorithm alg = <SigningAlgorithm>header?.alg;"
validatorSignatureConfig,"ValidatorSignatureConfig? validatorSignatureConfig = validatorConfig?.signatureConfig;"
headerPayloadPart,"string headerPayloadPart = encodedJwtComponents[0] + \".\" + encodedJwtComponents[1];"
assertion,"byte[] assertion = headerPayloadPart.toBytes();"
signature,"byte[] signature = check getJwtSignature(encodedJwtComponents[2]);"
jwksConfig,"var jwksConfig = validatorSignatureConfig?.jwksConfig;"
certFile,"string? certFile = validatorSignatureConfig?.certFile;"
trustStoreConfig,"var trustStoreConfig = validatorSignatureConfig?.trustStoreConfig;"
secret,"string? secret = validatorSignatureConfig?.secret;"
kid,"string? kid = header?.kid;"
url,"string url = <string> jwksConfig?.url;"
clientConfig,"ClientConfiguration clientConfig = <ClientConfiguration> jwksConfig?.clientConfig;"
jwk,"json jwk = check getJwk(kid, url, clientConfig, jwksCache);"
publicKey,"crypto:PublicKey publicKey = check getPublicKeyByJwks(jwk);"
signatureValidation,"boolean signatureValidation = check assertRsaSignature(alg, assertion, signature, publicKey);"
publicKey,"crypto:PublicKey|crypto:Error publicKey = crypto:decodeRsaPublicKeyFromCertFile(certFile);"
trustStore,"crypto:TrustStore trustStore = <crypto:TrustStore> trustStoreConfig?.trustStore;"
certAlias,"string certAlias = <string> trustStoreConfig?.certAlias;"
publicKey,"crypto:PublicKey|crypto:Error publicKey = crypto:decodeRsaPublicKeyFromTrustStore(trustStore, certAlias);"
signatureValidation,"boolean signatureValidation = check assertHmacSignature(alg, assertion, signature, secret);"
sub,"string? sub = validatorConfig?.username;"
iss,"string? iss = validatorConfig?.issuer;"
aud,"string|string[]? aud = validatorConfig?.audience;"
jwtId,"string? jwtId = validatorConfig?.jwtId;"
keyId,"string? keyId = validatorConfig?.keyId;"
customClaims,"map<json>? customClaims = validatorConfig?.customClaims;"
exp,"int? exp = payload?.exp;"
nbf,"int? nbf = payload?.nbf;"
alg,"SigningAlgorithm? alg = header?.alg;"
certificate,"crypto:Certificate? certificate = publicKey?.certificate;"
notBefore,"[int, decimal] notBefore = certificate.notBefore;"
notAfter,"[int, decimal] notAfter = certificate.notAfter;"
modulus,"json|error modulus = jwk.n;"
exponent,"json|error exponent = jwk.e;"
publicKey,"crypto:PublicKey|crypto:Error publicKey = crypto:buildRsaPublicKey(modulus, exponent);"
jwk,"any|cache:Error jwk = jwksCache.get(kid);"
stringResponse,"string|Error stringResponse = getJwksResponse(url, clientConfig);"
jwksArray,"json[] jwksArray = check getJwksArray(stringResponse);"
responseKid,"json|error responseKid = jwk.kid;"
jwks,"json|error jwks = jsonResponse.keys;"
result,"boolean|crypto:Error result = crypto:verifyRsaSha256Signature(assertion, signaturePart, publicKey);"
result,"boolean|crypto:Error result = crypto:verifyRsaSha384Signature(assertion, signaturePart, publicKey);"
result,"boolean|crypto:Error result = crypto:verifyRsaSha512Signature(assertion, signaturePart, publicKey);"
signature,"byte[]|crypto:Error signature = crypto:hmacSha256(assertion, secret.toBytes());"
signature,"byte[]|crypto:Error signature = crypto:hmacSha384(assertion, secret.toBytes());"
signature,"byte[]|crypto:Error signature = crypto:hmacSha512(assertion, secret.toBytes());"
usernamePayload,"string? usernamePayload = payload?.sub;"
issuePayload,"string? issuePayload = payload?.iss;"
audiencePayload,"string|string[]? audiencePayload = payload?.aud;"
jwtIdPayload,"string? jwtIdPayload = payload?.jti;"
keyIdHeader,"string? keyIdHeader = header?.kid;"
customClaimPayload,"json customClaimPayload = payload[key].toJson();"
customClaimConfig,"json customClaimConfig = customClaims[key];"
values,"string[] values = [];"
message,"readonly & websubhub:UpdateMessage? message = dequeue(topic);"
expiaryTime,"time:Utc expiaryTime = time:utcAddSeconds(time:utcNow(), timeout);"
payload,"string payload = generateResponsePayload(hubMode, messageBody, reason);"
payload,"string payload = string `${HUB_MODE}=${hubMode}`;"
payload,"string payload = \"\";"
messageParams,"string[] messageParams = [];"
responseHeaders,"map<string|string[]> responseHeaders = {};"
headers,"string[]|error headers = response.getHeaders(header);"
parameters,"map<string> parameters = {};"
queryParams,"string[] queryParams = regex:split(payload, \"&\");"
index,"int? index = query.indexOf(\"=\");"
name,"string name = query.substring(0, index);"
size,"int size = query.length();"
value,"string value = query.substring(index + 1, size);"
clientEp,"http:Client|error clientEp = new (url, config);"
contentType,"string contentType = retrieveContentType(message.contentType, message.content);"
payload,"json|xml|byte[] payload = retrieveRequestPayload(contentType, message.content);"
result,"error? result = request.setContentType(contentType);"
secret,"string? secret = self.secret;"
hash,"byte[]|error hash = generateSignature(secret, payload);"
response,"http:Response|error response = self.httpClient->post(\"\", request);"
errorMsg,"string errorMsg = string `Content distribution failed for topic [${self.topic}]`;"
messageBody,"map<string> messageBody = <map<string>>payload;"
keyArr,"byte[] keyArr = 'key.toBytes();"
inputArr,"byte[] inputArr = payload.toBytes();"
inputArr,"byte[] inputArr = payload.toString().toBytes();"
inputArr,"byte[] inputArr = payload.toJsonString().toBytes();"
status,"int status = response.statusCode;"
responseContentType,"string & readonly responseContentType = response.getContentType();"
responseHeaders,"map<string|string[]> responseHeaders = getHeaders(response);"
responsePayload,"string|byte[]|json|xml|map<string>? responsePayload = retrieveResponseBody(response, responseContentType);"
errorMsg,"string errorMsg = string `Subscription to topic [${topic}] is terminated by the subscriber`;"
errorMsg,"string errorMsg = \"Error occurred distributing updated content\";"
content,"var content = subscriberResponse.getJsonPayload();"
content,"var content = subscriberResponse.getXmlPayload();"
content,"var content = subscriberResponse.getTextPayload();"
content,"var content = subscriberResponse.getBinaryPayload();"
payload,"string & readonly payload = check req.getTextPayload();"
samplePayload,"json|xml|string|byte[]? samplePayload = ();"
resp,"http:Response resp = new;"
payload,"map<string[]> payload = req.getQueryParams();"
hubMode,"string[] hubMode = <string[]> payload[\"hub.mode\"];"
challengeArray,"string[] challengeArray = <string[]> payload[\"hub.challenge\"];"
retrievedResponseHeaders,"map<string|string[]> retrievedResponseHeaders = getHeaders(response);"
isSuccess,"boolean isSuccess = check hasAllHeaders(retrievedResponseHeaders);"
retrievedResponse,"http:Response retrievedResponse = check headerRetrievalTestingClient->post(\"/addHeaders\", request);"
retrievedResponseHeaders,"map<string|string[]> retrievedResponseHeaders = getHeaders(retrievedResponse);"
retrievedResponse,"http:Response retrievedResponse = check headerRetrievalTestingClient->post(\"/addPayload\", request);"
responseBody,"string|byte[]|json|xml|map<string>? responseBody = retrieveResponseBody(retrievedResponse, retrievedResponse.getContentType());"
expectedPayload,"json expectedPayload = { \"message\": \"This is a test message\" };"
expectedPayload,"xml expectedPayload = xml `<content><message>This is a test message</message></content>`;"
expectedPayload,"byte[] expectedPayload = \"This is a test message\".toBytes();"
message,"map<string> message = { \"query1\": \"value1\", \"query2\": \"value2\" };"
generatedQuery,"string generatedQuery = generateResponsePayload(\"denied\", message, \"reason1\");"
generatedQuery,"string generatedQuery = generateResponsePayload(\"denied\", message, ());"
generatedQuery,"string generatedQuery = retrieveTextPayloadForFormUrlEncodedMessage(message);"
message,"map<string> message = { \"query1\": \"value1\", \"query2\": \"value2\", \"query3\": \"value3\" };"
generatedResponseBody,"map<string> generatedResponseBody = getFormData(\"query1=value1&query2=value2&query3=value3\");"
retrievedValue,"string|string[] retrievedValue = retrievedHeaders.get(header);"
httpsConfig,"http:ClientConfiguration httpsConfig = { secureSocket: { cert: { path: \"tests/resources/ballerinaTruststore.p12\", password: \"ballerina\" } } };"
clientEp,"var clientEp = retrieveHttpClient(\"https: test:assertTrue(clientEp is http:Client);"
params,"[string, string?][] params = [ [\"key1\", \"val1\"], [\"key2\", \"val2\"] ];"
res,"http:Response res = check sendNotification(\"http:"
payload,"string payload = check res.getTextPayload();"
hubLeaseSeconds,"var hubLeaseSeconds = params.removeIfHasKey(HUB_LEASE_SECONDS);"
retrievedLeaseSeconds,"var retrievedLeaseSeconds = 'int:fromString(hubLeaseSeconds);"
response,"http:Response response = new;"
result,"SubscriptionAccepted|Redirect|error result = adaptor.callOnSubscriptionMethod(message, headers);"
errorDetails,"CommonResponse errorDetails = result.detail();"
errorDetails,"CommonResponse errorDetails = result is InternalSubscriptionError ? result.detail() : INTERNAL_SUBSCRIPTION_ERROR.detail();"
validationResult,"error? validationResult = validateSubscription(subscriptionValidationMethodAvailable, message, headers, adaptor);"
params,"[string, string?][] params = [ [HUB_MODE, MODE_DENIED], [HUB_TOPIC, message.hubTopic], [HUB_REASON, validationResult.message()] ];"
challenge,"string challenge = uuid:createType4AsString();"
params,"[string, string?][] params = [ [HUB_MODE, MODE_SUBSCRIBE], [HUB_TOPIC, message.hubTopic], [HUB_CHALLENGE, challenge], [HUB_LEASE_SECONDS, message.hubLeaseSeconds] ];"
subscriberResponse,"http:Response subscriberResponse = check sendNotification(message.hubCallback, params, config);"
respStringPayload,"string respStringPayload = check subscriberResponse.getTextPayload();"
verifiedMessage,"VerifiedSubscription verifiedMessage = { hub: message.hub, hubMode: message.hubMode, hubCallback: message.hubCallback, hubTopic: message.hubTopic, hubLeaseSeconds: message.hubLeaseSeconds, hubSecret: message.hubSecret };"
topic,"string topic = check retrieveQueryParameter(params, HUB_TOPIC);"
hubCallback,"string hubCallback = check retrieveQueryParameter(params, HUB_CALLBACK);"
message,"Unsubscription message = { hubMode: MODE_UNSUBSCRIBE, hubCallback: hubCallback, hubTopic: topic, hubSecret: params.removeIfHasKey(HUB_SECRET) };"
result,"UnsubscriptionAccepted|error result = adaptor.callOnUnsubscriptionMethod(message, headers);"
errorDetails,"CommonResponse errorDetails = result is InternalSubscriptionError ? result.detail() : INTERNAL_UNSUBSCRIPTION_ERROR.detail();"
validationResult,"error? validationResult = validateUnsubscription(unsubscriptionValidationMethodAvailable, message, headers, adaptor);"
params,"[string, string?][] params = [ [HUB_MODE, MODE_UNSUBSCRIBE], [HUB_TOPIC, message.hubTopic], [HUB_CHALLENGE, challenge] ];"
verifiedMessage,"VerifiedUnsubscription verifiedMessage = { hubMode: message.hubMode, hubCallback: message.hubCallback, hubTopic: message.hubTopic, hubSecret: message.hubSecret };"
message,"string message = string `Unknown type \"${argumentTypeName}\".`;"
message,"string message = string `Variable \"$${variableName}\" is not defined.`;"
inputValue,"__InputValue? inputValue = getInputValueFromArray(inputValues, argumentNode.getName());"
inputFieldValues,"__InputValue[] inputFieldValues = [];"
inputFieldType,"__Type? inputFieldType = getOfType(inputValue.'type);"
inputFieldValues,"__InputValue[]? inputFieldValues = inputFieldType?.inputFields;"
value,"parser:ArgumentValue[] value = [];"
modifiedArgNode,"parser:ArgumentNode modifiedArgNode = self.nodeModifierContext.getModifiedArgumentNode(argField);"
variableName,"string variableName = <string>argumentNode.getVariableName();"
defaultValue,"parser:ArgumentNode? defaultValue = variable.getDefaultValue();"
value,"json value = self.variables.get(variableName);"
hasInvalidValue,"boolean hasInvalidValue = self.hasInvalidDefaultValue(defaultValue, variableType);"
message,"string message = getInvalidDefaultValueError(variableName, variable.getTypeName(), defaultValue);"
location,"parser:Location location = argumentNode.getLocation();"
message,"string message = string `Variable \"$${variableName}\" of required type ${variable.getTypeName()} was `+ string `not provided.`;"
memberType,"__Type memberType = getListMemberTypeFromType(variableType);"
members,"parser:ArgumentValue[] members = <parser:ArgumentValue[]>defaultValue.getValue();"
member,"parser:ArgumentValue member = members[i];"
hasInvalidValue,"boolean hasInvalidValue = self.hasInvalidDefaultValue(member, memberType);"
listError,"string listError = string `${getListElementError(self.argumentPath)}`;"
message,"string message = getInvalidDefaultValueError(listError, getTypeNameFromType(memberType), member);"
message,"string message = getInvalidDefaultValueError(listError, getTypeNameFromType(variableType), defaultValue);"
modifiedArgNode,"parser:ArgumentNode modifiedArgNode = self.nodeModifierContext.getModifiedArgumentNode(argument);"
invalidValue,"string invalidValue = value is () ? \"null\": value.toString();"
message,"string message = string `Variable ${<string> modifiedArgNode.getVariableName()} expected value of type ` + string `\"${variableTypeName}\", found ${invalidValue}`;"
modifiedArgNode,"parser:ArgumentNode modifiedArgNode = self.nodeModifierContext.getModifiedArgumentNode(argNode);"
inputValue,"__InputValue? inputValue = getInputValueFromArray(inputValues, modifiedArgNode.getName());"
message,"string message = string `Variable \"${<string>modifiedArgNode.getVariableName()}\" of type `+ string `\"${variable.getTypeName()}\" used in position expecting type `+ string `\"${getTypeNameFromType(inputValue.'type)}\".`;"
wrapperType,"__Type wrapperType = { kind: NON_NULL };"
ofTypeName,"string ofTypeName = typeName.substring(0, typeName.length() - 1);"
ofType,"__Type? ofType;"
wrapperType,"__Type wrapperType = { kind: LIST };"
ofTypeName,"string ofTypeName = typeName.substring(1, typeName.length() - 1);"
isDefinedDirective,"boolean isDefinedDirective = false;"
previouslyModifiedNode,"parser:ArgumentNode previouslyModifiedNode = self.nodeModifierContext.getModifiedArgumentNode(originalNode);"
newModifiedNode,"parser:ArgumentNode newModifiedNode = previouslyModifiedNode.modifyWith(kind, value, valueLocation, isVarDef, variableValue, containsInvalidValue);"
err,"error? err = wait 'future;"
path,"string[] path = self.getSelectionPathFromData(data);"
errorDetail,"ErrorDetail errorDetail = { message: err.message(), locations: [selection.getLocation()], path: path.clone() };"
result,"any|error result;"
schema,"__Schema schema;"
engine,"Engine engine;"
context,"Context context;"
'field,"Field 'field = getFieldObject(fieldNode, operationType, schema, engine, result);"
clonedContext,"Context clonedContext = context.cloneWithoutErrors();"
resolvedResult,"readonly & anydata resolvedResult = engine.resolve(clonedContext, 'field);"
dataMap,"map<anydata> dataMap = <map<anydata>>data;"
path,"string[] path = <string[]>dataMap[PATH];"
interfaceType,"__Type? interfaceType = getTypeFromTypeArray(self.engine.getSchema().types, interfaceName);"
possibleTypes,"__Type[]? possibleTypes = interfaceType.possibleTypes;"
argumentNode,"parser:ArgumentNode argumentNode = fieldNode.getArguments()[0];"
result,"Acknowledgement|error? result = adaptor.callOnEventNotificationMethod(message, request);"
errorDetails,"var errorDetails = result.detail();"
responseError,"http:ListenerError? responseError = caller->respond(response);"
clientEp,"http:Client|error clientEp = new (url);"
originalRequest,"http:Request originalRequest = retrieveHttpRequest(msg);"
subscriberClientEp,"SubscriptionClient subscriberClientEp = check getSubscriberClient(hub, config?.httpConfig);"
request,"SubscriptionChangeRequest request = retrieveSubscriptionRequest(topic, config, callback);"
response,"SubscriptionChangeResponse response = check subscriberClientEp->subscribe(request);"
subscriptionSuccessMsg,"string subscriptionSuccessMsg = string `Subscription Request successfully sent to Hub[${response.hub}], for Topic[${response.topic}], with Callback [${callback}]`;"
hub,"string hub;"
topic,"string topic;"
resourceDetails,"[string, string]? resourceDetails = check retrieveResourceDetails(config);"
response,"SubscriptionChangeResponse response = check subscriberClientEp->unsubscribe(request);"
subscriptionSuccessMsg,"string subscriptionSuccessMsg = string `Unubscription Request successfully sent to Hub[${response.hub}], for Topic[${response.topic}], with Callback [${callback}]`;"
target,"string|[string, string]? target = serviceConfig?.target;"
discoveryConfig,"var discoveryConfig = serviceConfig?.discoveryConfig;"
expectedMediaTypes,"string?|string[] expectedMediaTypes = discoveryConfig?.accept ?: ();"
expectedLanguageTypes,"string?|string[] expectedLanguageTypes = discoveryConfig?.acceptLanguage ?: ();"
discoveryClient,"DiscoveryService discoveryClient = check new (target, discoveryConfig?.httpConfig);"
resourceDetails,"[string, string] resourceDetails = check discoveryClient->discoverResourceUrls(expectedMediaTypes, expectedLanguageTypes);"
linkHeaders,"string[] linkHeaders = [];"
hubIndex,"int hubIndex = 0;"
hubs,"string[] hubs = [];"
topic,"string topic = \"\";"
linkHeaderConstituents,"string[] linkHeaderConstituents = [];"
linkConstituents,"string[] linkConstituents = regex:split(link, \";\");"
url,"string url = linkConstituents[0].trim();"
